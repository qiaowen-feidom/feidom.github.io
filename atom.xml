<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>feidom up up up</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://feidom-up.github.io/"/>
  <updated>2021-06-18T06:13:57.164Z</updated>
  <id>https://feidom-up.github.io/</id>
  
  <author>
    <name>乔文飞</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React-防止内存泄漏处理</title>
    <link href="https://feidom-up.github.io/2021/06/18/React-%E9%98%B2%E6%AD%A2%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%A4%84%E7%90%86/"/>
    <id>https://feidom-up.github.io/2021/06/18/React-%E9%98%B2%E6%AD%A2%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%A4%84%E7%90%86/</id>
    <published>2021-06-18T05:40:49.000Z</published>
    <updated>2021-06-18T06:13:57.164Z</updated>
    
    <content type="html"><![CDATA[<p>用React写了一段代码，浏览器的控制台<font color=red size=5>Error </font>如下：<br><font color=red>Warning: Can’t perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in a useEffect cleanup function.</font></p><p>啥意思呢：不能在未挂载的组件上执行React状态更新。这是一个无用功，但它表明你的应用程序中存在内存泄漏。要解决这个问题，在useEffect清理函数中取消所有的订阅和异步任务。</p><p>以下是这段问题代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Component = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; itemId &#125; = props;</span><br><span class="line">  <span class="keyword">const</span> [ isRemoveing, setIsRemoveing ] = useState(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> handlerRemove = <span class="keyword">async</span>() =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(isRemoveing) <span class="keyword">return</span>;</span><br><span class="line">    setIsRemoveing(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">await</span> removeItem(itemId); <span class="comment">// 删除当前这个组件的数据，这个组件卸载</span></span><br><span class="line">    setIsRemoveing(<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;div class_name=&#123; !isRemoveing ? <span class="string">'class1'</span> : <span class="string">'class2'</span> &#125; onClick=&#123;handlerRemove&#125; &gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>原因是啥呢</strong>：await等待一个异步请求的返回再<code>setIsRemoveing</code>。假如这个组件unmounted之后，请求还没回来，你还在这setState，不就炸了。</p><p>好吧，那解决方式是不是在<code>useEffect</code>中定义一个卸载时的变量<code>unmounted</code>，然后在setIsRemoveing时判断卸载状态？</p><p>嗯，基本是这个思路。那这个<code>unmounted</code>该怎么定义，是直接<code>const unmounted = false;</code>, 还是<code>const [ unmounted, setUnmounted ] = useState(false);</code>？<br>以下是Stack Overflow里一个帖子的回复：</p><ul><li>方式一：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> unmounted = <span class="literal">false</span>;</span><br><span class="line">  setPageLoading(<span class="literal">true</span>);</span><br><span class="line">  props</span><br><span class="line">    .dispatch(fetchCourses())</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!unmounted) &#123;</span><br><span class="line">        setPageLoading(<span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">error: string</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!unmounted) &#123;</span><br><span class="line">        toast.error(error);</span><br><span class="line">        setPageLoading(<span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123; unmounted = <span class="literal">true</span> &#125;;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure></li><li>方式二：useRef<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Example = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> unmounted = useRef(<span class="literal">false</span>);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123; unmounted.current = <span class="literal">true</span> &#125;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> setFilter = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    props.dispatch(fetchCourses()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!unmounted.current) &#123;</span><br><span class="line">        setLoading(<span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ReactTable onFetchData=&#123;setFilter&#125; <span class="comment">/* other props omitted */</span> /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>方式二中如果不用ref，用state或者直接定义变量的话，都实现不了。<br>好吧，是我不熟悉的<a class="link"   href="https://zh-hans.reactjs.org/docs/hooks-reference.html#useref"  target="_blank" rel="noopener">useRef<i class="fas fa-external-link-alt"></i></a>,这个链接是官方文档，可以先看下。<br>然后为了研究它，我找到一篇来自<a class="link"   href="https://leewarrick.com/"  target="_blank" rel="noopener">Lee Warrick<i class="fas fa-external-link-alt"></i></a>的<a class="link"   href="https://leewarrick.com/blog/react-use-effect-explained/"  target="_blank" rel="noopener">React’s useEffect and useRef Explained for Mortals<i class="fas fa-external-link-alt"></i></a>。<a href="/2021/06/18/useEffect-useRef/">这里</a>是我对这篇文章的翻译，仅供参考。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a class="link"   href="https://daviseford.com/blog/2019/07/11/react-hooks-check-if-mounted.html"  target="_blank" rel="noopener">React Hooks - Check If A Component Is Mounted<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://stackoverflow.com/questions/58038008/how-to-stop-memory-leak-in-useeffect-hook-react/58038029"  target="_blank" rel="noopener">how-to-stop-memory-leak-in-useeffect-hook-react<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用React写了一段代码，浏览器的控制台&lt;font color=red size=5&gt;Error &lt;/font&gt;如下：&lt;br&gt;&lt;font color=red&gt;Warning: Can’t perform a React state update on an unmounte
      
    
    </summary>
    
    
      <category term="react" scheme="https://feidom-up.github.io/categories/react/"/>
    
    
      <category term="react" scheme="https://feidom-up.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>useEffect &amp; useRef</title>
    <link href="https://feidom-up.github.io/2021/06/18/useEffect-useRef/"/>
    <id>https://feidom-up.github.io/2021/06/18/useEffect-useRef/</id>
    <published>2021-06-18T01:58:48.000Z</published>
    <updated>2021-06-18T05:39:21.666Z</updated>
    
    <content type="html"><![CDATA[<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>本文是一片翻译，原文来自<a class="link"   href="https://leewarrick.com/"  target="_blank" rel="noopener">Lee Warrick<i class="fas fa-external-link-alt"></i></a>的<a class="link"   href="https://leewarrick.com/blog/react-use-effect-explained/"  target="_blank" rel="noopener">React’s useEffect and useRef Explained for Mortals<i class="fas fa-external-link-alt"></i></a>。<br>为啥翻译并记录这篇文章呢，因为看了以后觉得通俗易懂的为凡人解释了<code>useEffect</code>和<code>useRef</code>。<br>在此记录，方便以后回头复习。</p><h4 id="通俗的解释React的-useEffect-和-useRef"><a href="#通俗的解释React的-useEffect-和-useRef" class="headerlink" title="通俗的解释React的 useEffect 和 useRef"></a>通俗的解释React的 useEffect 和 useRef</h4><p><img src="https://leewarrick.com/blog/static/fdb92914fc9093dee6a2c20dad8fbd50/c35de/acropolis.jpg" alt="原文中过的图"><br>&emsp;&emsp;如果React文档让你一筹莫展，或者Dan Abramov的博客让你觉得你在阅读从奥林匹斯山流传下来的古希腊文卷轴，你并不孤单,不是只有你这样认为。<br>&emsp;&emsp;有时，React神殿的众神们很难将他们的智慧转化为我们其他人可以理解的语言。事情通常是这样的。你在使用React时遇到困难，用谷歌搜索你的问题，然后读到一个博客或Stack Overflow的帖子，其中的一些建议让你感到比开始时更迷茫。<br>&emsp;&emsp;我当然也曾多次成为这种情况的受害者。特别是useEffect。在我们深入研究这个特殊的钩子之前，让我说我喜欢用hooks来写React，而且不想再回到类中去。这就是说，useEffect是一个很大的痛点。</p><h6 id="到底什么是“effect副作用”"><a href="#到底什么是“effect副作用”" class="headerlink" title="到底什么是“effect副作用”"></a>到底什么是“effect副作用”</h6><p>&emsp;&emsp;为了让你真正理解useEffect，让我们退后一点，谈谈编程和JavaScript。<br>&emsp;&emsp;useEffect的名字就是我们亲切地称为 “副作用 “的效果。<br>&emsp;&emsp;那么什么是副作用呢？它是一段代码，它伸出手来……做别的事情。这是一个抽象的概念，所以让我们用例子来说明。<br>&emsp;&emsp;这里有一个没有副作用的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;函数add除了接受一个输入并返回一个输出外，什么也没做。它并没有伸手到自身以外的地方去捣乱!<br>&emsp;&emsp;我们来介绍一个副作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resultDiv = <span class="built_in">document</span>.getElementById(<span class="string">'add-example'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = a + b</span><br><span class="line">  resultDiv.textContent = <span class="string">`The Result is <span class="subst">$&#123;result&#125;</span>`</span></span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;add-example&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;现在，我们的函数伸到了自身之外来更新DOM（Document Object Model的缩写），并显示了结果。这个额外的行为是一个副作用。</p><h6 id="React中的副作用"><a href="#React中的副作用" class="headerlink" title="React中的副作用"></a>React中的副作用</h6><p>&emsp;&emsp;那么React呢？它是一个几乎只更新DOM的库。一个视图库，如果你愿意的话。那么在React中，你会把什么叫做副作用呢？<br>&emsp;&emsp;任何在更新页面之外的东西。如果你不使用React来更新状态或渲染HTML，那就是一个副作用。它是任何非React的东西。<br>&emsp;&emsp;这意味着任何时候你调用API，使用setInterval/setTimeout，添加键盘监听器，或者真的任何时候你搞乱窗口对象，你都在引入副作用。<br>&emsp;&emsp;hooks很神奇，让你写出真正可读、可重用的代码……除了当你处理副作用的时候。这很不幸，因为当你仔细想想，作为网络开发者，我们所做的大多数有趣的事情都是围绕着副作用展开的。<br>&emsp;&emsp;让我们从钩子上退一步，看看我们如何在基于类的组件中处理副作用。</p><h6 id="类组件和副作用"><a href="#类组件和副作用" class="headerlink" title="类组件和副作用"></a>类组件和副作用</h6><p>&emsp;&emsp;在基于类的组件中，我们会使用生命周期方法来执行侧面效果。例如，在componentDidMount上，我们会调用API来获取渲染的数据。<br>&emsp;&emsp;”为什么不在构造函数中调用API？”你可能会问。好吧，因为React说我们用于渲染的东西都在 “状态 “中，在我们的组件被加载到页面上之前，我们不能乱用状态。如果我们试图在组件加载之前更新状态，就会出现错误。<br>&emsp;&emsp;下面是一个典型的基于类的组件的情况,这是一个小精灵的例子（后面会用hooks改写）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pokemon</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    fetch(<span class="string">'https://pokeapi.co/api/v2/pokemon/gengar/'</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(res)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> pokemon = <span class="keyword">this</span>.state</span><br><span class="line">    <span class="keyword">const</span> style = &#123;<span class="attr">textTransform</span>: <span class="string">'capitalize'</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">      &#123; pokemon</span><br><span class="line">        ? <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line">          &lt;img src=&#123;pokemon.sprites.front_default&#125;</span><br><span class="line"><span class="xml">            alt=&#123;'Image of ' + pokemon.name&#125;/&gt;</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&#123;style&#125;</span>&gt;</span>Name: &#123;pokemon.name&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">          &lt;p style=&#123;style&#125;&gt;</span><br><span class="line">            Type: &#123;pokemon.types.map(x =&gt; x.type.name).join(', ')&#125;</span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">        : <span class="string">'Loading...'</span></span><br><span class="line">      &#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样做很好，除了不这样做的时候。当我们想再次点击API来抓取不同的小精灵时会发生什么？如果这个组件被连接到我们的应用程序中的某个路由上，而这个路由发生了变化，但这个组件并没有卸载/重装。如果用户进入了不同的页面，而组件在API调用结束前就卸载了怎么办？<br>&emsp;&emsp;答案是增加更多的生命周期方法，如<code>componentDidUpdate</code>和<code>componentWillUnmount</code>，以执行更多的API调用，防止奇怪的卸载错误。所以我们添加了这些生命周期方法来处理我们所有的边缘情况。当我们完成后，我们发现我们的大部分组件都是由生命周期代码组成的。</p><h5 id="然后来试一下Hooks"><a href="#然后来试一下Hooks" class="headerlink" title="然后来试一下Hooks"></a>然后来试一下Hooks</h5><p>&emsp;&emsp;React团队意识到，类的API有点笨重，难以推理。人们正在制作生命周期流程图，试图了解React的内部运作……这是一个混乱。<br>&emsp;&emsp;因此，在2018年10月的ReactConf上，在Sophie Alpert概述了类的使用有多么糟糕之后，Dan Abramov上台介绍了钩子（你可以在这里观看视频）。<br>&emsp;&emsp;钩子在功能组件中引入了状态性，以及处理副作用的新方法。钩子使React的代码更容易重复使用，而且代码量更少–这是一个巨大的胜利！但是有一个小问题。<br>&emsp;&emsp;除了一个小问题。<strong>每次渲染，整个组件/功能都要重新运行</strong>。<br>&emsp;&emsp;让我们看一个基于Hooks开发的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RerenderExample</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [bool, setBool] = React.useState(<span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">const</span> randomNum = <span class="built_in">Math</span>.random()</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;This number will be different each time you click the button:&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;&#123;randomNum&#125;&lt;/</span>p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setBool(!bool)&#125;&gt;Trigger a render&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们在渲染的JSX中甚至没有使用bool，但每次状态改变时，整个函数都会运行。每次渲染，组件内的所有东西都会重新运行：函数定义、变量创建/分配等等。<br>&emsp;&emsp;如果你在想 “如果我必须在组件中做一些计算量大的事情怎么办？这不可能是高性能的……”，这是个敏锐的观察。在一个功能性组件中进行昂贵的操作是不可能有性能的。事实上，useCallback和useMemo的存在正是为了解决这个问题而设置的避难所。Kent C Dodds在这里对这些问题有一个挑战性的解读，但总结起来，根据Kent的说法，在你看到性能影响之前，你不应该担心重读的问题。</p><blockquote><p>注意：如果你对钩子不熟悉，请把这篇文章收藏起来，等你准备好了再来看看。除非你必须要担心记忆化的问题<br>&emsp;&emsp;像useState这样的钩子采用了一些内在的魔法来避免重现的问题。这很好，而且使用useState似乎很简单，但是<strong>当你需要做设置状态以外的事情时，怎么办？</strong><br>&emsp;&emsp;使用useEffect。那些讨厌的生命周期方法没有了，万岁！然而，这个钩子也有它自己的奇怪之处。首先让我们来看看语法。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//accepts two arguments: a function, and dependency array</span></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do stuff</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125; <span class="comment">//function to undo our stuff from above when component unmounts</span></span><br><span class="line">&#125;, []) <span class="comment">//dependency array of things to watch for changes on</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;所以你给useEffect传递一个要运行的回调函数，其中包含你的副作用，然后是一个要观察的事物的数组。如果被监视的事物发生变化，useEffect将重新运行我们的回调函数。如果你需要在卸载时清理你的副作用，返回一个包含该代码的函数。<br>&emsp;&emsp;让我们看看我们的小精灵的例子，用钩子和useEffect。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Pokemon</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [pokemon, setPokemon] = React.useState(<span class="literal">null</span>)</span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    fetch(<span class="string">'https://pokeapi.co/api/v2/pokemon/gengar/'</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      setPokemon(res)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, []) <span class="comment">// empty array means nothing to watch, so run once and no more</span></span><br><span class="line">  <span class="keyword">const</span> style = &#123;<span class="attr">textTransform</span>: <span class="string">'capitalize'</span>&#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    &#123; pokemon</span><br><span class="line">      ? <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line">        &lt;img src=&#123;pokemon.sprites.front_default&#125;</span><br><span class="line"><span class="xml">            alt=&#123;'Image of ' + pokemon.name&#125;/&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&#123;style&#125;</span>&gt;</span>Name: &#123;pokemon.name&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">        &lt;p style=&#123;style&#125;&gt;</span><br><span class="line">          Type: &#123;pokemon.types.map(x =&gt; x.type.name).join(', ')&#125;</span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">      : <span class="string">'Loading...'</span></span><br><span class="line">    &#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果你盯着那个空的依赖性数组，你已经注意到了第一个useEffect的怪癖。通过传递一个空数组，我们在说 “只做这一次”。React万神殿告诉我们，在极少数情况下这是可以的，但大多数时候你都希望里面有东西。原因是，通常你想与你的代码中的东西同步，而不是只执行一次效果。例如，如果我们的小精灵组件依赖于一个路由参数或道具，任何可以说 “去获得一个新的小精灵 “而不需要挂载/卸载的东西呢？<br>&emsp;&emsp;比方说，我们的组件依赖于一个道具pokemonToGet，它是一个参数，告诉它要从API中获得哪些小精灵。让我们也为测试目的添加一个小小的表单。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Pokemon</span>(<span class="params">&#123;pokemonToGet&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [pokemon, setPokemon] = React.useState(<span class="literal">null</span>)</span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    fetch(<span class="string">`https://pokeapi.co/api/v2/pokemon/<span class="subst">$&#123;pokemonToGet&#125;</span>/`</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      setPokemon(res)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, [pokemonToGet]) <span class="comment">// get a new pokemon with the pokemonToGet prop changes</span></span><br><span class="line">  <span class="keyword">const</span> style = &#123;<span class="attr">textTransform</span>: <span class="string">'capitalize'</span>&#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    &#123; pokemon</span><br><span class="line">      ? <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line">        &lt;img src=&#123;pokemon.sprites.front_default&#125;</span><br><span class="line"><span class="xml">          alt=&#123;'Image of ' + pokemon.name&#125;/&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&#123;style&#125;</span>&gt;</span>Name: &#123;pokemon.name&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">        &lt;p style=&#123;style&#125;&gt;</span><br><span class="line">          Type: &#123;pokemon.types.map(x =&gt; x.type.name).join(', ')&#125;</span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">      : <span class="string">'Loading...'</span></span><br><span class="line">    &#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">function PokemonForm() &#123;</span></span><br><span class="line"><span class="regexp">  const [inputValue, setInputValue] = React.useState("rowlet")</span></span><br><span class="line"><span class="regexp">  const [pokemonToGet, setPokemonToGet] = React.useState("gengar")</span></span><br><span class="line"><span class="regexp">  function getPokemon() &#123;</span></span><br><span class="line"><span class="regexp">    setPokemonToGet(inputValue.trim().toLowerCase())</span></span><br><span class="line"><span class="regexp">    setInputValue("")</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;input onChange=&#123;(e) =&gt; setInputValue(e.target.value)&#125;</span></span><br><span class="line"><span class="regexp">        value=&#123;inputValue&#125; type="text"/</span>&gt;</span><br><span class="line">      &lt;button onClick=&#123;getPokemon&#125;&gt;</span><br><span class="line">        Get Pokemon</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Pokemon pokemonToGet=&#123;pokemonToGet&#125; /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">render(&lt;PokemonForm /</span>&gt;)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;很好，现在我们的组件根据我们的道具变化获取了一个新的小精灵。如果使用类，我们就必须使用<code>componentDidUpdate</code>之类的东西来达到类似的效果。<br>&emsp;&emsp;Ryan Florence在推特上对useEffect的用法做了很好的总结。</p><blockquote><p>The question is not “when does this effect run” the question is “with which state does this effect synchronize with”<br>  useEffect(fn) // all state<br>  useEffect(fn, []) // no state<br>  useEffect(fn, [these, states])</p></blockquote><p>&emsp;&emsp;他提到的 “所有状态 “的情况，即你没有传入任何依赖关系的情况是一个奇怪的情况。我个人从未发现它的用途。我们知道整个组件在每次渲染时都会运行，所以我想知道是否有一些奇怪的边缘情况需要你使用<code>useEffect(fn)</code>而不使用任何依赖阵列。在任何情况下，大多数时候你都会用这个方法：<code>useEffect(fn, [these, states])</code>。</p><h5 id="UseEffect和Previous-State-事情败露的地方。"><a href="#UseEffect和Previous-State-事情败露的地方。" class="headerlink" title="UseEffect和Previous State: 事情败露的地方。"></a>UseEffect和Previous State: 事情败露的地方。</h5><p>&emsp;&emsp;到目前为止，useEffect的心理模型似乎很简单：将它与你选择的某些状态变化同步。问题是，当你需要在一个效果中引用该状态，而不仅仅是知道它是否发生了变化。<br>&emsp;&emsp;在useEffect中，你无法获得对当前状态的访问。<br>&emsp;&emsp;在我们的API调用例子中，我们没有看到这一点，因为我们只是覆盖了之前的状态。<br>&emsp;&emsp;让我们看一个简单的例子:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = React.useState(<span class="number">0</span>);</span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> intervalId = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        setCount(count + <span class="number">1</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(intervalId)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;The count is: &#123;count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;似乎我们做了所有正确的事情（甚至清理了卸载时的副作用），但我们的计数器没有递增。这是一个问题吗？我们是否无法访问setInterval所属的窗口对象？<br>&emsp;&emsp;不是，也不是。如果你把console.log添加到那个间隔中，你会看到它每秒钟都在跳动。<br>&emsp;&emsp;我可以证明给你看:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = React.useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> [randomNum, setRandomNum] = React.useState(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> intervalId = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setCount(count + <span class="number">1</span>)</span><br><span class="line">      setRandomNum(<span class="built_in">Math</span>.random())</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(intervalId)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;The count is: &#123;count&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;RandomNum is &#123;randomNum&#125;&lt;/</span>p&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意，我们每秒钟都会得到一个新的随机数。我们的时间间隔代码是好的。<br>&emsp;&emsp;我们能够设置新的状态，但无法访问当前状态。<br>&emsp;&emsp;这就是一个 “陈旧的闭包”。我不会去讨论闭包，但只需知道，由于React/hooks的实现，在我们的间隔函数中，count变量总是会是0。这是一个旧的参考。<br>&emsp;&emsp;事实证明，像上面这样的简单例子有一个解决方案，正如John Tucker所指出的（谢谢John！）。和基于类的组件中的setState一样，useState也可以接受一个回调函数，接收之前的状态作为一个参数。React文档也注意到了这一点。<br>&emsp;&emsp;下面是一个快速修复的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = React.useState(<span class="number">0</span>);</span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> intervalId = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//let's pass a function instead</span></span><br><span class="line">      <span class="comment">//the argument is the current state</span></span><br><span class="line">      setCount(<span class="function"><span class="params">count</span> =&gt;</span> count + <span class="number">1</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(intervalId)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;The count is: &#123;count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;不过，这仍然不能解决我们所有的问题。如果你需要在useEffect中访问最新的状态，但不更新它，你将不得不开始用setState回调来包装你的useEffect代码，然后在最后返回未改变的状态。这很快就会变成一个绝对的混乱，特别是当你在处理多个状态值的时候。<br>&emsp;&emsp;另一个可能的解决方案是只使用useReducer，因为它可以接收之前的状态，但是用副作用填充你的reducer也显得非常混乱，而且我不建议任何人完全停止使用useState。<br>&emsp;&emsp;无论如何，在写钩子的时候，我已经陷入了陈旧的闭包陷阱很多很多次。我甚至不知道它有个名字，直到我在Svelte背后的人Rich Harris的演讲中看到它<br>&emsp;&emsp;显然，我也不是唯一一个在钩子上被它们绊倒的人。<br><img src="https://leewarrick.com/blog/static/5a5dbcc6667a5da9eeabc5cbe90a1427/ed46b/staleclosures.png" alt="Rich Harris的"><br>&emsp;&emsp; <strong>React甚至在他们的文档中提到了这一点。</strong></p><blockquote><p>“Any function inside a component, including event handlers and effects, “sees” the props and state from the render it was created in.”<br>  译：组件内的任何功能，包括事件处理程序和效果，都能 “看到 “它所创建的渲染中的道具和状态。<br>&emsp;&emsp;我之前读过这个，在真正深入了解这个问题之前，我觉得没什么意义。我想象这可能是React的一个不好的点，所以也许他们不希望太大声地叫出来。<br>&emsp;&emsp;然而，Dan Abramov在他的博客中更好地描述了这个问题，甚至提供了一个解决方案。<br>“Effects always “see” props and state from the render they were defined in. That helps prevent bugs but in some cases can be annoying. For those cases, you can explicitly maintain some value in a mutable ref.”<br>  译：效果总是 “看到 “它们所定义的渲染中的道具和状态。这有助于防止bug，但在某些情况下会很烦人。对于这些情况，你可以明确地在一个可变的上下文中保存一些值。</p></blockquote><p>&emsp;&emsp;这很有帮助，因为它以useRef的形式提供了一个解决方案（感谢Dan！），但它让我对如何帮助避免这个问题一无所知（主要是因为我不了解useRef）。</p><h5 id="什么是“ref”，你会怎么使用它"><a href="#什么是“ref”，你会怎么使用它" class="headerlink" title="什么是“ref”，你会怎么使用它"></a>什么是“ref”，你会怎么使用它</h5><p>&emsp;&emsp;传统上，引用的目的是让你直接访问一个html元素。例如，假设你需要关注一个输入字段。你必须跳出React，使用常规的JavaScript来调用.focus()。钩子实际上让这一切变得相当简单。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">InputField</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = React.useRef()</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input type=<span class="string">"text"</span> ref=&#123;inputRef&#125; /&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; inputRef.current.focus()&#125;&gt;</span><br><span class="line">        Click to Focus the input</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;很好! 当我们需要的时候，Refs是访问本地DOM APIs的一个简单的逃生通道。<br>&emsp;&emsp;…但这如何帮助我们解决我们陈旧的关闭计数器的例子呢？</p><h5 id="使用“Refs”来避免陈旧的闭包"><a href="#使用“Refs”来避免陈旧的闭包" class="headerlink" title="使用“Refs”来避免陈旧的闭包"></a>使用“Refs”来避免陈旧的闭包</h5><p>&emsp;&emsp;React文档将“Refs”比作 “实例变量”。我不知道那是什么意思（谢谢维基百科），所以我觉得那没什么用。<br>&emsp;&emsp;我设法通过这样思考来理解Refs的含义。<br>&emsp;&emsp;<strong>Refs存在于重新渲染周期之外。</strong><br>&emsp;&emsp;<strong>把Refs看作是你设置在一边的一个变量。当你的组件重新运行时，它会很高兴地跳过这个反射，直到你用<code>.current</code>调用它。</strong><br>&emsp;&emsp;让我们看看对我们的定时器例子的修正。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = React.useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> countRef = React.useRef(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> intervalId = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      countRef.current = countRef.current + <span class="number">1</span></span><br><span class="line">      setCount(countRef.current)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(intervalId)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;The count is: &#123;count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果我们想把计时器停在比如说10的位置，我们可以很容易地用refs来做。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = React.useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> countRef = React.useRef(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> intervalId = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (countRef.current === <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">return</span> clearInterval(intervalId)</span><br><span class="line">      countRef.current = countRef.current + <span class="number">1</span></span><br><span class="line">      setCount(countRef.current)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(intervalId)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;The count is: &#123;count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;为了便于比较，这里是使用setState回调方法的替代方案。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = React.useState(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> intervalId = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        setCount(<span class="function"><span class="params">count</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (count === <span class="number">10</span>) &#123;</span><br><span class="line">            clearInterval(intervalId)</span><br><span class="line">            <span class="keyword">return</span> count</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">return</span> count + <span class="number">1</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(intervalId)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;The count is: &#123;count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到这很快就会接近回调地狱，所以如果你在做更复杂的事情，我会提醒你不要使用回调方法。</p><h5 id="State-Versus-Refs"><a href="#State-Versus-Refs" class="headerlink" title="State Versus Refs"></a>State Versus Refs</h5><p>&emsp;&emsp;是否有可能完全抛弃状态而只使用refs？<br>&emsp;&emsp;你可能倾向于认为你可以用 refs 来代替你的组件的状态，从而避开所有这些奇怪的行为。<br>&emsp;&emsp;你不能这样做。refs不是反应性的。当你改变一个 ref 时，它不会导致重新渲染。记住，<strong>它们存在于重新渲染周期之外</strong>。<br>&emsp;&emsp;以下是不可能的:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> count = React.useRef(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> intervalId = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      count.current = count.current + <span class="number">1</span></span><br><span class="line">      <span class="comment">//console.log('Ref example count: ' + count.current)</span></span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(intervalId)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;The count is: &#123;count.current&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那个组件实际上是在内部进行计数，但它并没有导致HTML的更新。你需要useState来实现这一点。如果你不相信我的话，请继续取消对console.log的注释）。<br>&emsp;&emsp;这里有一个例子来证明Refs与state。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = React.useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> countRef = React.useRef(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;State Count: &#123;count&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Increment State Count</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">      &lt;p&gt;Ref Count: &#123;countRef.current&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; countRef.current = countRef.current + 1&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Increment Ref Count</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">render(&lt;Counter/</span>&gt;)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在你通过设置状态触发重新渲染之前，你不会看到Ref计数的变化。</p><h5 id="离别感言"><a href="#离别感言" class="headerlink" title="离别感言"></a>离别感言</h5><p>&emsp;&emsp;我喜欢React中的钩子和功能组件，但我所概述的怪异现象让我暂停了。我不喜欢被要求对React的内部工作了解这么多才能使用它。我认为这给学习React的人带来了障碍，我希望将来React团队能想出一些更好的方法来处理这些问题。</p><h4 id="翻译结束"><a href="#翻译结束" class="headerlink" title="翻译结束"></a>翻译结束</h4><p>很棒的文章。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;注意&quot;&gt;&lt;a href=&quot;#注意&quot; class=&quot;headerlink&quot; title=&quot;注意&quot;&gt;&lt;/a&gt;注意&lt;/h4&gt;&lt;p&gt;本文是一片翻译，原文来自&lt;a class=&quot;link&quot;   href=&quot;https://leewarrick.com/&quot;  target=&quot;
      
    
    </summary>
    
    
      <category term="react" scheme="https://feidom-up.github.io/categories/react/"/>
    
    
      <category term="react" scheme="https://feidom-up.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>Touch和Mouse事件</title>
    <link href="https://feidom-up.github.io/2021/06/07/touch%E5%92%8Cmouse%E4%BA%8B%E4%BB%B6/"/>
    <id>https://feidom-up.github.io/2021/06/07/touch%E5%92%8Cmouse%E4%BA%8B%E4%BB%B6/</id>
    <published>2021-06-07T00:28:00.000Z</published>
    <updated>2021-06-07T02:25:21.190Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一个问题引发的思考"><a href="#一个问题引发的思考" class="headerlink" title="一个问题引发的思考"></a>一个问题引发的思考</h4><p>移动端的一个页面，猜测哈，hover事件&amp;mouseover事件都被监听时，mouse应该失效吧。因为移动端只有点触，没有mouse。<br>事实：出现mouseover（定义了这个时候的样式）状态，就很奇怪。<br>然后，本以为mouse和touch在浏览器中是这样的：</p><ul><li>pc端：mouse事件生效，touch事件<del>失效</del></li><li>移动端：mouse事件<del>失效</del>，touch事件生效</li><li><strong>但是</strong>，结果是这样的：<br>同时监听了mouse和touch两种事件，在ios移动设备中的safari浏览器中，点击触发touch事件之后，定义的mouseover事件也触发了，产生了bug。</li></ul><h4 id="研究它"><a href="#研究它" class="headerlink" title="研究它"></a>研究它</h4><p>敲黑板：</p><ul><li>pc端：onTouch事件会被屏蔽。</li><li>移动端：两种事件都会被触发。且顺序是这样的：<ol><li>touchstart</li><li>touchmove</li><li>touchend</li><li>mouseover</li><li>mousemove</li><li>mousedown</li><li>mouseup</li><li>click</li></ol></li></ul><p>好吧，这是这一切出现的原因。<br>在适配多种设备的项目中，怎么区分这两种事件，让mouse事件在移动端失效呢。</p><h4 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h4><ul><li>设置一个flag，mouse事件时判断touchFlag决定return或者执行。</li><li>分开写，判断设备后需要mouse的写mouse，需要touch的写touch。</li><li>最好的方法：preventDefault()<blockquote><p><strong>Use preventDefault() inside touch event handlers, so the default mouse-emulation handling doesn’t occur.</strong></p></blockquote></li></ul><h4 id="preventDefault"><a href="#preventDefault" class="headerlink" title="preventDefault()"></a>preventDefault()</h4><p>专门挑出来说一下这个：preventDefault()【该方法将通知 Web 浏览器不要执行与事件关联的默认动作（如果存在这样的动作）。】<br>于是，在<code>touchstart</code>方法中使用<code>e.preventDefault()</code>去阻止之后的mouseover事件。<br><font color='red'>报错了</font>：Unable to preventDefault inside passive event listener due to target being treated as passive.</p><blockquote><p>翻译： 由于目标被视为被动，无法在被动事件监听器内防止。</p></blockquote><h5 id="passive-的事件监听器"><a href="#passive-的事件监听器" class="headerlink" title="passive 的事件监听器"></a>passive 的事件监听器</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">addEventListener(type, listener, &#123;</span><br><span class="line">    capture: <span class="literal">false</span>,</span><br><span class="line">    passive: <span class="literal">true</span>,</span><br><span class="line">    once: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>三个属性都是布尔类型的开关。其中 capture 属性等价于以前的 useCapture 参数；once 属性就是表明该监听器是一次性的，执行一次后就被自动 removeEventListener 掉，还没有浏览器实现它；passive 属性在 Firefox 和 Chrome 已经实现。<br>很多移动端的页面都会监听 touchstart 等 touch 事件，像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"touchstart"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    ... <span class="comment">// 浏览器不知道这里会不会有 e.preventDefault()</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>由于 touchstart 事件对象的 cancelable 属性为 true，也就是说它的默认行为可以被监听器通过 preventDefault() 方法阻止，那它的默认行为是什么呢，通常来说就是滚动当前页面（还可能是缩放页面），如果它的默认行为被阻止了，页面就必须静止不动。但浏览器无法预先知道一个监听器会不会调用 preventDefault()，它能做的只有等监听器执行完后再去执行默认行为，而监听器执行是要耗时的，有些甚至耗时很明显，这样就会导致页面卡顿。</p><p>Passive Event Listeners：就是告诉前页面内的事件监听器内部是否会调用<code>preventDefault</code>函数来阻止事件的默认行为，以便浏览器根据这个信息更好地做出决策来优化页面性能。当属性passive的值为true的时候，代表该监听器内部不会调用<code>preventDefault</code>函数来阻止默认滑动行为，Chrome浏览器称这类型的监听器为被动（passive）监听器。目前Chrome主要利用该特性来优化页面的滑动性能，所以Passive Event Listeners特性当前仅支持mousewheel/touch相关事件。</p><p><strong>耗时是什么</strong><br>当用户在移动设备上点击网页中的某个元素时，没有为移动交互设计的网页在触摸开始事件和处理鼠标事件（mousedown）之间至少有300毫秒的延迟。如果你有触摸设备，你可以看看这个例子。或者，使用Chrome浏览器，你可以在Chrome开发者工具中打开 “模拟触摸事件”，以帮助你在非触摸系统上测试触摸界面!</p><p>这个延迟是为了让浏览器有时间判断用户是否在做其他手势–特别是双击缩放。很明显，在你想对手指触摸做出即时反应的情况下，这可能是个问题。目前正在进行的工作是试图限制这种延迟自动发生的情况。</p><table><thead><tr><th align="left"></th><th align="left">Chrome for Android</th><th align="left">Android Browser</th><th align="left">Opera Mobile for Android</th><th align="left">Firefox for Android</th><th align="left">Safari iOS</th></tr></thead><tbody><tr><td align="left">Non-scalable viewport</td><td align="left">No delay</td><td align="left">300ms</td><td align="left">300ms</td><td align="left">No delay</td><td align="left">300ms</td></tr><tr><td align="left">No Viewport</td><td align="left">300ms</td><td align="left">300ms</td><td align="left">300ms</td><td align="left">300ms</td><td align="left">300ms</td></tr></tbody></table><p>避免这种问题的一个简单方法，就是直接告诉浏览器，我这个页面不需要滚动：<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,user-scalable=no&quot;&gt;</code>，一般在移动端这样写可以。</p><p><strong>综上</strong>：<br>  事件监听时，设置第三个参数中：passive为false，告诉浏览器我要自己控制<code>preventDefault</code>函数来阻止事件的默认行为。</p><p><strong>如下</strong>：<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private onTouchStart(e:MouseEvent) &#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'onTouchStart'</span>, e.cancelable);</span><br><span class="line">&#125;</span><br><span class="line">private onMouseOver(e:MouseEvent) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'onMouseOver'</span>, e.cancelable);</span><br><span class="line">&#125;</span><br><span class="line">componentDidMount() &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.touchElement) &#123;</span><br><span class="line">    <span class="keyword">this</span>.touchElement.addEventListener(<span class="string">'touchstart'</span>, <span class="keyword">this</span>.onTouchStart, &#123;<span class="attr">passive</span>: <span class="literal">false</span>&#125;);</span><br><span class="line">    <span class="keyword">this</span>.touchElement.addEventListener(<span class="string">'mouseover'</span>, <span class="keyword">this</span>.onMouseOver, &#123;<span class="attr">passive</span>: <span class="literal">false</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div styleName=&#123;<span class="string">'btn-start-wrap'</span>&#125; ref=&#123;</span><br><span class="line">  (ref) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (ref) &#123;</span><br><span class="line">      <span class="keyword">this</span>.touchElement = ref;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&#125;&gt;</span><br></pre></td></tr></table></figure><br>  以上的代码touchstart后不会触发mouseover。实现了阻止移动端也触发mouse事件的逻辑。</p><h4 id="参见："><a href="#参见：" class="headerlink" title="参见："></a>参见：</h4><p>  <a class="link"   href="https://www.jianshu.com/p/5bae6433025f"  target="_blank" rel="noopener">Passive Event Listeners——让页面滑动更加流畅的新特性<i class="fas fa-external-link-alt"></i></a><br>  <a class="link"   href="https://www.cnblogs.com/ziyunfei/p/5545439.html"  target="_blank" rel="noopener">紫云飞 – passive 的事件监听器<i class="fas fa-external-link-alt"></i></a><br>  <a class="link"   href="https://www.html5rocks.com/en/mobile/touchandmouse/"  target="_blank" rel="noopener">touch&amp;mouse<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一个问题引发的思考&quot;&gt;&lt;a href=&quot;#一个问题引发的思考&quot; class=&quot;headerlink&quot; title=&quot;一个问题引发的思考&quot;&gt;&lt;/a&gt;一个问题引发的思考&lt;/h4&gt;&lt;p&gt;移动端的一个页面，猜测哈，hover事件&amp;amp;mouseover事件都被监听时，
      
    
    </summary>
    
    
      <category term="移动端" scheme="https://feidom-up.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
      <category term="移动端" scheme="https://feidom-up.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>webpackPlugins</title>
    <link href="https://feidom-up.github.io/2021/05/28/webpackPlugins/"/>
    <id>https://feidom-up.github.io/2021/05/28/webpackPlugins/</id>
    <published>2021-05-28T02:07:55.000Z</published>
    <updated>2021-05-28T02:15:59.420Z</updated>
    
    <content type="html"><![CDATA[<h4 id="webpack-DefinePlugin"><a href="#webpack-DefinePlugin" class="headerlink" title="webpack.DefinePlugin"></a>webpack.DefinePlugin</h4><ul><li>简介<br>在编译时创建一个可以配置的全局变量，在区分开发模式｜生产模式的不同时十分有用。</li><li>使用：<ul><li>在webpack的plugins中，增加<code>webpack.DefinePlugin(Object)</code>的实例</li><li>方法中传入的Object的key值，可以在项目所有import的文件中使用。</li><li>使用时得到的是key对应额value，这里在编译时，并不是变量的引用，而是<strong>编译时直接替换</strong><blockquote><p>因为这个插件直接执行文本替换，给定的值必须包含字符串本身内的实际引号。通常，有两种方式来达到这个效果，使用 ‘“production”‘, 或者使用 JSON.stringify(‘production’)。</p></blockquote></li></ul></li><li>文档地址<ul><li><a class="link"   href="https://v4.webpack.docschina.org/plugins/define-plugin/"  target="_blank" rel="noopener">webpack.DefinePlugin<i class="fas fa-external-link-alt"></i></a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;webpack-DefinePlugin&quot;&gt;&lt;a href=&quot;#webpack-DefinePlugin&quot; class=&quot;headerlink&quot; title=&quot;webpack.DefinePlugin&quot;&gt;&lt;/a&gt;webpack.DefinePlugin&lt;/h4&gt;&lt;
      
    
    </summary>
    
    
      <category term="webpack" scheme="https://feidom-up.github.io/categories/webpack/"/>
    
    
      <category term="前端工程化" scheme="https://feidom-up.github.io/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
      <category term="webpack" scheme="https://feidom-up.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>vue3的数据响应式系统</title>
    <link href="https://feidom-up.github.io/2021/03/19/vue3%E7%9A%84%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    <id>https://feidom-up.github.io/2021/03/19/vue3%E7%9A%84%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-03-19T07:54:57.000Z</published>
    <updated>2021-05-06T02:46:51.787Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Vue2-0的数据监听"><a href="#Vue2-0的数据监听" class="headerlink" title="Vue2.0的数据监听"></a>Vue2.0的数据监听</h3><p><strong>Object.defineProperty</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(object1, <span class="string">'property1'</span>, &#123;</span><br><span class="line">    value: <span class="number">42</span>,</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    <span class="keyword">get</span>()&#123;&#125;,</span><br><span class="line">    <span class="keyword">set</span>(newValue) &#123; bValue = newValue; &#125;,</span><br><span class="line">    enumerable : <span class="literal">true</span>,</span><br><span class="line">    configurable : <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">object1.property1 = <span class="number">77</span>;</span><br><span class="line"><span class="comment">// throws an error in strict mode</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(object1.property1);</span><br><span class="line"><span class="comment">// expected output: 42</span></span><br></pre></td></tr></table></figure><h3 id="Vue3-0的数据响应式系统"><a href="#Vue3-0的数据响应式系统" class="headerlink" title="Vue3.0的数据响应式系统"></a>Vue3.0的数据响应式系统</h3><p><strong>proxy</strong> get\set</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用vue-next(3)源码中'packages/reactivity/dist/reactivity.global.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;reactive, effect&#125; = VueObserver;</span><br><span class="line"><span class="comment">//  reactive: 把数据处理成为响应式数据</span></span><br><span class="line"><span class="comment">//  effect: </span></span><br><span class="line"><span class="comment">//      1.首先会执行一次对应的监听函数</span></span><br><span class="line"><span class="comment">//      2.修改对应监听函数内使用的响应式数据，对应的监听函数就会立即执行，重新执行的过程就会获取新的数据</span></span><br><span class="line"><span class="keyword">const</span> yideng = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> state = reactive(yideng);</span><br><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> count = state.count;</span><br><span class="line">    <span class="keyword">const</span>.log(<span class="string">'当前的count'</span>, count)</span><br><span class="line">    <span class="comment">//render(count)  如果在这触发render渲染</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">effect(fn)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Vue2-0的数据监听&quot;&gt;&lt;a href=&quot;#Vue2-0的数据监听&quot; class=&quot;headerlink&quot; title=&quot;Vue2.0的数据监听&quot;&gt;&lt;/a&gt;Vue2.0的数据监听&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Object.defineProperty&lt;/str
      
    
    </summary>
    
    
      <category term="vue" scheme="https://feidom-up.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="https://feidom-up.github.io/tags/vue/"/>
    
      <category term="vue源码解读" scheme="https://feidom-up.github.io/tags/vue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法之队列</title>
    <link href="https://feidom-up.github.io/2021/03/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%98%9F%E5%88%97/"/>
    <id>https://feidom-up.github.io/2021/03/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%98%9F%E5%88%97/</id>
    <published>2021-03-17T10:44:26.000Z</published>
    <updated>2021-05-06T02:46:51.790Z</updated>
    
    <content type="html"><![CDATA[<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul><li>特性：先进先出</li><li>解题法则：<ul><li>题目具备<strong>广度遍历（分层遍历）</strong>和<strong>顺序输出</strong>的特点，就应该想到用FIFO 队列来试一试。</li><li><strong>滑动窗口</strong>类型题</li></ul></li><li>模板：<ul><li>分层遍历</li><li>循环队列</li><li>单调队列</li></ul></li></ul><hr><h5 id="普通队列"><a href="#普通队列" class="headerlink" title="普通队列"></a>普通队列</h5><ul><li>例题1：从上到下按层打印二叉树，同一层结点按从左到右的顺序打印，每一层打印到一行。<br>  输入： <pre><code>   39     8    6   7</code></pre>  输出：<code>[[3], [9, 8], [6, 7]]</code></li></ul><p><strong>二叉树的层次遍历</strong>的解题技巧</p><ul><li>遍历方式的变化：<ul><li>二叉树的锯齿形遍历</li><li>二叉树层次倒序遍历</li></ul></li><li>层的信息变化<ul><li>二叉树的层平均值</li><li>二叉树最深层的叶节点的和</li><li>二叉树的最大宽度</li></ul></li><li>树的变化<ul><li>N叉树的层次遍历</li><li>N叉树的最大深度</li></ul></li></ul><hr><h5 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h5><ul><li>重点： 循环使用固定空间</li><li>难点： 控制好 front/rear 两个首尾指示器</li><li>空队列和满队列的判断，在于<code>used</code>变量</li><li>例题2：设计一个可以容纳 k 个元素的循环队列。需要实现以下接口：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参数k表示这个循环队列最多只能容纳k个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCircularQueue</span><span class="params">(<span class="keyword">int</span> k)</span></span>;</span><br><span class="line">    <span class="comment">// 将value放到队列中, 成功返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line">    <span class="comment">// 删除队首元素，成功返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deQueue</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 得到队首元素，如果为空，返回-1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Front</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 得到队尾元素，如果队列为空，返回-1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Rear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 看一下循环队列是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 看一下循环队列是否已放满k个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h5><ul><li>概念： 要求队列中的元素必须满足单调性，比如<strong>单调递增</strong>，或者<strong>单调递减</strong>。单调队列属于双端队列的一种。双端队列与 FIFO 队列的区别在于：<ul><li>FIFO 队列只能从尾部添加元素，首部弹出元素；</li><li>双端队列可以从首尾两端 push/pop 元素。</li></ul></li><li>注意： 单调队列在入队的时候，需要满足 2 点：<ul><li>入队前队列已经满足单调性；</li><li>入队后队列仍然满足单调性。</li></ul></li><li>例题3：滑动窗口的最大值<br>  输入：nums = [1,3,-1,-3,5,3], k = 3<br>  输出：[3,3,5,5]<blockquote><p>符合<font color=red>单调递减队列！</font></p></blockquote></li><li>例题4： 给定一个数组 A[]，每个位置 i 放置了金币 A[i]，小明从 A[0] 出发。当小明走到 A[i] 的时候，下一步他可以选择 A[i+1, i+k]（当然，不能超出数组边界）。每个位置一旦被选择，将会把那个位置的金币收走（如果为负数，就要交出金币）。请问，最多能收集多少金币？<br>  输入：[1,-1,-100,-1000,100,3], k = 2<br>  输出：4<br>  解释：从 A[0] = 1 出发，收获金币 1。下一步走往 A[2] = -100, 收获金币 -100。再下一步走到 A[4] = 100，收获金币 100，最后走到 A[5] = 3，收获金币 3。最多收获 1 - 100 + 100 + 3 = 4。没有比这个更好的走法了。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;队列&quot;&gt;&lt;a href=&quot;#队列&quot; class=&quot;headerlink&quot; title=&quot;队列&quot;&gt;&lt;/a&gt;队列&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;特性：先进先出&lt;/li&gt;
&lt;li&gt;解题法则：&lt;ul&gt;
&lt;li&gt;题目具备&lt;strong&gt;广度遍历（分层遍历）&lt;/strong&gt;和&lt;
      
    
    </summary>
    
    
      <category term="算法" scheme="https://feidom-up.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="https://feidom-up.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://feidom-up.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="队列" scheme="https://feidom-up.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>手写代码系列之New(fn)</title>
    <link href="https://feidom-up.github.io/2021/03/17/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%B3%BB%E5%88%97%E4%B9%8BNew-fn/"/>
    <id>https://feidom-up.github.io/2021/03/17/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%B3%BB%E5%88%97%E4%B9%8BNew-fn/</id>
    <published>2021-03-17T00:46:47.000Z</published>
    <updated>2021-05-06T02:46:51.789Z</updated>
    
    <content type="html"><![CDATA[<h3 id="New操作符做了哪些事"><a href="#New操作符做了哪些事" class="headerlink" title="New操作符做了哪些事"></a>New操作符做了哪些事</h3><ul><li>创建了一个全新的对象。</li><li>会被执行[[Prototype]]（也就是<strong>proto</strong>）链接。</li><li>使this指向新创建的对象。</li><li>通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上。</li><li>如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用将返回该对象引用。</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li><p>版本一：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个对象，且将其隐式原型指向构造函数原型</span></span><br><span class="line">        <span class="keyword">let</span> obj = &#123;</span><br><span class="line">            __proto__: fn.prototype</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行构造函数</span></span><br><span class="line">        fn.call(obj, ...arguments)</span><br><span class="line">        <span class="comment">// 返回该对象</span></span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = myNew(Person)(<span class="string">'chen'</span>, <span class="number">18</span>)</span><br></pre></td></tr></table></figure></li><li><p>版本二：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span>(fn.prototype !==<span class="literal">null</span>)&#123;</span><br><span class="line">        res.__proto__ = fn.prototype;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> ret = fn.apply(res, <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> ret === <span class="string">"object"</span> || <span class="keyword">typeof</span> ret === <span class="string">"function"</span>) &amp;&amp; ret !== <span class="literal">null</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用示例：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> obj = New(A, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// equals to</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> A(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;New操作符做了哪些事&quot;&gt;&lt;a href=&quot;#New操作符做了哪些事&quot; class=&quot;headerlink&quot; title=&quot;New操作符做了哪些事&quot;&gt;&lt;/a&gt;New操作符做了哪些事&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;创建了一个全新的对象。&lt;/li&gt;
&lt;li&gt;会被执行[[P
      
    
    </summary>
    
    
      <category term="手写代码系列" scheme="https://feidom-up.github.io/categories/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>手写代码系列之防抖与节流</title>
    <link href="https://feidom-up.github.io/2021/03/16/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%B3%BB%E5%88%97%E4%B9%8B%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"/>
    <id>https://feidom-up.github.io/2021/03/16/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%B3%BB%E5%88%97%E4%B9%8B%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</id>
    <published>2021-03-16T07:26:28.000Z</published>
    <updated>2021-05-06T02:46:51.790Z</updated>
    
    <content type="html"><![CDATA[<h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p><strong>思路</strong>：在规定时间内未触发第二次，则执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 利用闭包保存定时器</span></span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="comment">// 在规定时间内再次触发</span></span><br><span class="line">        <span class="comment">// 会先清除定时器再重设定时器</span></span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            fn.apply(context, args)</span><br><span class="line">        &#125;,delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用举例：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"防抖"</span>)</span><br><span class="line">&#125;</span><br><span class="line">addEventListener(<span class="string">"scroll"</span>, debounce(fn1, <span class="number">1000</span>))</span><br></pre></td></tr></table></figure><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p><strong>思路</strong>：在规定时间内只触发一次</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 利用闭包保存时间</span></span><br><span class="line">    <span class="keyword">let</span> prev = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">let</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="keyword">if</span>(now - prev &gt;= delay)&#123;</span><br><span class="line">            fn.apply(context, args);</span><br><span class="line">            prev = <span class="built_in">Date</span>.now();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用举例：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"节流"</span>)</span><br><span class="line">&#125;</span><br><span class="line">addEventListener(<span class="string">"scroll"</span>, throttle(fn2, <span class="number">1000</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;防抖&quot;&gt;&lt;a href=&quot;#防抖&quot; class=&quot;headerlink&quot; title=&quot;防抖&quot;&gt;&lt;/a&gt;防抖&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;：在规定时间内未触发第二次，则执行&lt;/p&gt;
&lt;figure class=&quot;highlight java
      
    
    </summary>
    
    
      <category term="手写代码系列" scheme="https://feidom-up.github.io/categories/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>手写代码咔咔咔</title>
    <link href="https://feidom-up.github.io/2021/03/16/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E5%92%94%E5%92%94%E5%92%94/"/>
    <id>https://feidom-up.github.io/2021/03/16/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E5%92%94%E5%92%94%E5%92%94/</id>
    <published>2021-03-16T07:24:51.000Z</published>
    <updated>2021-06-07T00:44:44.878Z</updated>
    
    <content type="html"><![CDATA[<h3 id="咔咔咔"><a href="#咔咔咔" class="headerlink" title="咔咔咔"></a>咔咔咔</h3><ul><li><a href="/2021/03/16/手写代码系列之防抖与节流/">手写代码系列之防抖与节流</a></li><li><a href="/2021/03/17/手写代码系列之New-fn/">New</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;咔咔咔&quot;&gt;&lt;a href=&quot;#咔咔咔&quot; class=&quot;headerlink&quot; title=&quot;咔咔咔&quot;&gt;&lt;/a&gt;咔咔咔&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2021/03/16/手写代码系列之防抖与节流/&quot;&gt;手写代码系列之防抖与节流&lt;/a&gt;&lt;/li&gt;
&lt;l
      
    
    </summary>
    
    
      <category term="手写代码系列" scheme="https://feidom-up.github.io/categories/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法之栈结构</title>
    <link href="https://feidom-up.github.io/2021/03/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A0%88%E7%BB%93%E6%9E%84/"/>
    <id>https://feidom-up.github.io/2021/03/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A0%88%E7%BB%93%E6%9E%84/</id>
    <published>2021-03-16T07:15:17.000Z</published>
    <updated>2021-05-06T02:46:51.790Z</updated>
    
    <content type="html"><![CDATA[<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul><li>特性：先进后出</li><li>解题法则：<ul><li>题目中有<strong>配对、消除</strong>的题意，优先考虑<strong>栈</strong>结构</li><li>栈中存放的可以是<strong>内容本身</strong>和<strong>内容的索引</strong></li><li>数组中右边<strong>第一个比我小</strong>的元素的位置，求解用<strong>递增栈</strong></li><li>较小的数<strong>消除</strong>掉较大的数的时候，使用<strong>递增栈</strong>。</li><li>根据题意总结<strong>入栈与出栈的时机</strong></li></ul></li></ul><h5 id="普通栈"><a href="#普通栈" class="headerlink" title="普通栈"></a>普通栈</h5><ul><li>规律性：<font color=red>配对、消除</font></li></ul><hr><ul><li>例题1：字符串中只有字符’(‘和’)’。合法字符串需要括号可以配对。比如：<br>  输入：”()”<br>  输出：true<br>  解释：()，()()，(())是合法的。)(，()(，(()是非法的。<br>  请你实现一个函数<code>isValid(s)</code>，来判断给定的字符串是否合法。<blockquote><p>针对例1这种<font color=green>内容一样</font>时，可以使用<font color=green>计数器优化</font></p></blockquote></li><li>例题拓展： 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。有效字符串需满足：<br>  左括号必须用相同类型的右括号闭合<br>  左括号必须以正确的顺序闭合<br>  注意空字符串可被认为是有效字符串<br>  请实现<code>isValid(s)</code></li></ul><hr><ul><li>例题2：在水中有许多鱼，可以认为这些鱼停放在 x 轴上。再给定两个数组 Size，Dir，Size[i] 表示第 i 条鱼的大小，Dir[i] 表示鱼的方向 （0 表示向左游，1 表示向右游）。这两个数组分别表示鱼的大小和游动的方向，并且两个数组的长度相等。鱼的行为符合以下几个条件:<br>  所有的鱼都同时开始游动，每次按照鱼的方向，都游动一个单位距离；<br>  当方向相对时，大鱼会吃掉小鱼；<br>  鱼的大小都不一样。<br>  输入：Size = [4, 2, 5, 3, 1], Dir = [1, 1, 0, 0, 0]<br>  输出：3<br>  完成<code>solution(Size, Dir)</code>来计算还剩下几条鱼？</li></ul><hr><h5 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h5><ul><li>定义：单调栈就是指栈中的元素必须是按照升序排列的栈，或者是降序排列的栈。<br>  升序排列的栈称为<strong>递增栈</strong><br>  降序排列的栈称为<strong>递减栈</strong><br>  特点：任何时候都需要保证栈的有序性</li></ul><hr><ul><li>例题1：一个整数数组 A，找到每个元素：右边第一个比我小的下标位置，没有则用 -1 表示。（找出数组中右边比我小的元素）<br>  输入：[5, 2]<br>  输出：[1, -1]<br>  解释：因为元素 5 的右边离我最近且比我小的位置应该是 A[1]，最后一个元素 2 右边没有比 2 小的元素，所以应该输出 -1。</li></ul><blockquote><p>类似题：<br>数组中右边第一个比我大的元素的位置<br>数组中元素左边离我最近且比我小的元素的位置<br>数组中元素左边离我最近且比我大的元素的位置</p></blockquote><ul><li>例题2：给定一个正整数数组和 k，要求依次取出 k 个数，输出其中数组的一个子序列，需要满足：1. 长度为 k；2.字典序最小。<br>  输入：nums = [3,5,2,6], k = 2<br>  输出：[2,6]<br>  解释：在所有可能的解：{[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]} 中，[2,6] 字典序最小。</li></ul><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><p><img src="https://s0.lgstatic.com/i/image6/M01/0B/7F/CioPOWA4q6qASB-UAADhj7uzOwg933.png" alt="图"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;栈&quot;&gt;&lt;a href=&quot;#栈&quot; class=&quot;headerlink&quot; title=&quot;栈&quot;&gt;&lt;/a&gt;栈&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;特性：先进后出&lt;/li&gt;
&lt;li&gt;解题法则：&lt;ul&gt;
&lt;li&gt;题目中有&lt;strong&gt;配对、消除&lt;/strong&gt;的题意，优先考虑&lt;st
      
    
    </summary>
    
    
      <category term="算法" scheme="https://feidom-up.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="https://feidom-up.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://feidom-up.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="栈" scheme="https://feidom-up.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法</title>
    <link href="https://feidom-up.github.io/2021/03/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>https://feidom-up.github.io/2021/03/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</id>
    <published>2021-03-03T01:34:21.000Z</published>
    <updated>2021-05-06T02:46:51.790Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法四步分析法："><a href="#算法四步分析法：" class="headerlink" title="算法四步分析法："></a>算法四步分析法：</h3><ol><li>模拟：模拟题目的运行。</li><li>规律：尝试总结出题目的一般规律和特点。</li><li>匹配：找到符合这些特点的数据结构与算法。</li><li>边界：考虑特殊情况。</li></ol><h3 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h3><ul><li><a href="/2021/03/16/数据结构与算法之栈结构/">栈结构与算法</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法四步分析法：&quot;&gt;&lt;a href=&quot;#算法四步分析法：&quot; class=&quot;headerlink&quot; title=&quot;算法四步分析法：&quot;&gt;&lt;/a&gt;算法四步分析法：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;模拟：模拟题目的运行。&lt;/li&gt;
&lt;li&gt;规律：尝试总结出题目的一般规律和特点。
      
    
    </summary>
    
    
      <category term="算法" scheme="https://feidom-up.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="https://feidom-up.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://feidom-up.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Virtual DOM的工作原理</title>
    <link href="https://feidom-up.github.io/2021/01/02/%E8%99%9A%E6%8B%9Fdom/"/>
    <id>https://feidom-up.github.io/2021/01/02/%E8%99%9A%E6%8B%9Fdom/</id>
    <published>2021-01-02T15:22:41.000Z</published>
    <updated>2021-05-06T02:46:51.790Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Virtual-DOM-也被称为虚拟DOM"><a href="#Virtual-DOM-也被称为虚拟DOM" class="headerlink" title="Virtual DOM 也被称为虚拟DOM"></a>Virtual DOM 也被称为虚拟DOM</h4><ul><li>在react中，<code>jsx语法</code>经过<code>babel解析</code>转化为<code>React.createElement()</code>函数调用后生成<code>ast抽象语法树</code>，再通过<code>render</code>函数将<code>ast树</code>转换为<code>fiber 结构</code>，填入许多调度、更新、diff相关数据，并转换<code>ast树</code>为<code>虚拟DOM树</code>，再完成挂载。</li><li>在vue中，模版语法 经过 <code>generate</code>处理(正则匹配 生成 <code>ast抽象语法树</code>)，<code>render</code>中调用<code>_c()/createElement()</code>函数将<code>ast树</code>生成<code>VNode(虚拟DOM)</code>,再完成挂载。</li></ul><h4 id="虚拟DOM的来源"><a href="#虚拟DOM的来源" class="headerlink" title="虚拟DOM的来源"></a>虚拟DOM的来源</h4><p>react的前身是facebook的<code>XHP</code>，在这个框架中，页面都是通过转义的方式生成的，并没有直接的HTML，确保在<code>XHP</code>中写出安全的静态页面。</p><p>初衷是：</p><ul><li>简化前端开发（后端赋能）</li><li>防止xss攻击</li></ul><p>发展是：</p><ul><li>通过虚拟DOM规避风险，不让用户直接的操作DOM了，而是把它封起来自己管理</li></ul><h4 id="虚拟DOM的表现形式"><a href="#虚拟DOM的表现形式" class="headerlink" title="虚拟DOM的表现形式"></a>虚拟DOM的表现形式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    tag: <span class="string">'input'</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">        type: <span class="string">'button'</span>,</span><br><span class="line">        value: <span class="string">''</span></span><br><span class="line">    &#125;,</span><br><span class="line">    childrean: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>React 有两个函数<br>    * diff 函数，去计算状态变更前后的虚拟 DOM 树差异<br>    * 渲染函数，渲染整个虚拟 DOM 树或者处理差异点。<br>    现在是不是有些理解为什么 React 与 ReactDOM 是两个库了？正是由于计算与渲染的分工。<br>    其中 React 的主要工作是组件实现、更新调度；ReactDOM 提供了在 网页上渲染 的基础</p></blockquote><h4 id="虚拟DOM的优缺点"><a href="#虚拟DOM的优缺点" class="headerlink" title="虚拟DOM的优缺点"></a>虚拟DOM的优缺点</h4><p>优点</p><ul><li>性能优越</li><li>规避XSS</li><li>可跨平台</li></ul><p>但是不是所有的操作都是虚拟DOM更高效<br>&emsp;&emsp;大量的直接操作DOM容易引起页面性能下降。这时React基于虚拟DOM的diff处理与批处理操作，可降低DOM的操作频次和范围，提升页面性能<br>&emsp;&emsp;但是在首次渲染或者微量dom操作的时候，虚拟DOM的性能就更慢一些。</p><p>那虚拟 DOM 一定可以规避 XSS吗？<br>&emsp;&emsp;虚拟 DOM 内部确保了字符转义，所以确实可以做到这点，但 React 存在风险，因为 React 留有 dangerouslySetInnerHTML API 绕过转义。</p><p>没有虚拟 DOM 不能实现跨平台吗？<br>&emsp;&emsp;比如 NativeScript 没有虚拟 DOM 层 ，它是通过提供兼容原生 API 的 JS API 实现跨平台开发。<br>那虚拟 DOM 的优势在哪里？<br>&emsp;&emsp;实际上它的优势在于跨平台的成本更低。在 React Native 之后，前端社区从虚拟 DOM 中体会到了跨平台的无限前景，<br>所以在后续的发展中，都借鉴了虚拟 DOM。比如：社区流行的小程序同构方案，在构建过程中会提供类似虚拟 DOM 的结构描述对象，来支撑多端转换。</p><p>缺点</p><ul><li>内存占用较高</li><li>难以进行优化</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Virtual-DOM-也被称为虚拟DOM&quot;&gt;&lt;a href=&quot;#Virtual-DOM-也被称为虚拟DOM&quot; class=&quot;headerlink&quot; title=&quot;Virtual DOM 也被称为虚拟DOM&quot;&gt;&lt;/a&gt;Virtual DOM 也被称为虚拟DOM&lt;/
      
    
    </summary>
    
    
      <category term="react" scheme="https://feidom-up.github.io/categories/react/"/>
    
      <category term="vue" scheme="https://feidom-up.github.io/categories/react/vue/"/>
    
    
      <category term="react" scheme="https://feidom-up.github.io/tags/react/"/>
    
      <category term="vue" scheme="https://feidom-up.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Serverless是什么</title>
    <link href="https://feidom-up.github.io/2021/01/01/Serverless%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>https://feidom-up.github.io/2021/01/01/Serverless%E6%98%AF%E4%BB%80%E4%B9%88/</id>
    <published>2021-01-01T13:59:56.000Z</published>
    <updated>2021-05-06T02:46:51.785Z</updated>
    
    <content type="html"><![CDATA[<h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><ul><li><p>广义上来说<br>是构建和运行软件时不需要关心服务器的一种架构思想。虽然 Serverless 翻译过来是 “无服务器”，但这并不代表着应用运行不需要服务器，而是开发者不需要关心服务器。而基于 Serverless 思想实现的软件架构就是 Serverless 架构。</p></li><li><p>狭义上说<br>  狭义的 Serverless 是 <code>FaaS</code> 和 <code>BaaS</code> 的组合。</p><ul><li>FaaS（Function as a Service）：<ol><li>FaaS本质上是一个函数运行平台，函数运行时，你对底层的服务器是无感知的，FaaS 产品会负责资源的调度和运维，这是它的特点之一，<strong>不用运维</strong>。</li><li>FaaS 中的函数也不是持续运行的，而是通过事件进行触发，比如 HTTP 事件、消息事件等，产生事件的源头叫触发器，FaaS 平台会集成这些触发器，我们直接用就行，这是 FaaS 的第二个特点，<strong>事件驱动</strong>。</li><li>FaaS 的第三个特点是<strong>按量付费</strong>。 FaaS 产品的收费方式，都是按照函数执行次数和执行时消耗的 CPU、内存等资源进行计费的。</li><li>FaaS 在运行函数的时候，会根据并发量自动生成多个函数实例，并且并发理论是没有上限的，这是它的第四个特点，<strong>弹性伸缩</strong>。</li></ol><ul><li>FaaS 每次执行函数时，都会初始化一个新的运行环境，然后从头开始执行整个代码，而不是只执行其中的 handler 方法。执行完毕后，运行环境就会被释放。这样每次函数执行，都是新的运行环境，自然不同函数之间就无法共用 pv 这个变量了。FaaS 的另一个特点，<strong>无状态</strong>。</li></ul></li><li>BaaS（Backend as a Service）<br> 为了解决分布式中的状态共享问题<br> BaaS 本质上就是把后端功能封装起来，以接口的形式提供服务。</li></ul></li><li><p>总<br>基于 FaaS 和 BaaS 的架构，是一种计算和存储分离的架构。 计算由 FaaS 负责，存储由 BaaS 负责，计算和存储也被分开部署和收费。这使应用的存储不再是应用本身的一部分，而是演变成了独立的云服务，降低了数据丢失的风险。而应用本身也变成了无状态的应用，更容易进行调度和扩缩容。</p></li></ul><p>基于 FaaS 和 BaaS ，你的应用就实现了自动弹性伸缩、按量付费、不用关心服务器，这正是 Serverless 架构的必要因素。所以说狭义的 Serverless 是 FaaS 和 BaaS 的组合。</p><h3 id="与其他架构的区别"><a href="#与其他架构的区别" class="headerlink" title="与其他架构的区别"></a>与其他架构的区别</h3><ul><li>PaaS<br>  PaaS （平台即服务）是云计算虚拟机时代的主要形态之一。 它是指云厂商提供开发工具、依赖库、服务和运行平台等能力，开发者可以依赖这些能力将自己的应用直接部署在云平台上，不用关心底层的计算资源、网络、存储等。虽然与Serverless 很类似，但依旧存在一些区别。</li><li>Kubernetes<br>  Kubernetes 是一种容器编排技术。在 Kubernetes 中应用运行的基本单位是 Pod（容器组），Pod 是应用及运行环境的集合，所以你也不用关心服务器了。基于 Kubernetes，你能很方便地进行 Pod 的管理，并且实现应用的弹性伸缩。<br>  所以，Kubernetes 是介于 Serverful 和 Serverless 中间的产物。</li></ul><p><strong>Serverless 是云原生的一种实现，云原生的另一种实现是 Kubernetes。</strong></p><table><thead><tr><th align="left">Serverless</th><th align="left">PaaS （平台即服务）</th><th align="left">Kubernetes</th></tr></thead><tbody><tr><td align="left">按实际使用量付费</td><td align="left">按资源付费</td><td align="left">按照资源数量计费</td></tr></tbody></table><h3 id="Serverless-的优缺点"><a href="#Serverless-的优缺点" class="headerlink" title="Serverless 的优缺点"></a>Serverless 的优缺点</h3><ul><li>优点：不用运维、弹性伸缩、节省成本、开发简单、降低风险、易于扩展。</li><li>缺点：<ol><li>依赖第三方服务：一旦你选择了一个云厂商，要想从一个云移到另一个台，成本很高</li><li>底层硬件的多样性：代码依赖的地层硬件多样性</li><li>应用性能瓶颈：函数运行前需要现初始化函数运行环境，这个过程需要消耗一定时间。因为函数不是持续“在线”的，而是需要运行的时候才启动（不像传统应用，服务是一直启动的）。</li><li>函数通信效率低：在 Serverless 应用中，函数与函数之间就完全独立了。如果两个函数的数据有依赖，需要进行通信、交换数据，就要进行函数与函数之间的调用（调用方式是 HTTP 调用）。相比之前的内存调用，数据交互效率显然低了很多。而这个问题的本质，是 FaaS 还没有比较好的数据通信协议或方案。</li><li>开发调试复杂：Serverless 架构正处于飞速发展的阶段，其开发、调试、部署工具链并不完善（基本是每个云厂商各玩各的）</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;是什么&quot;&gt;&lt;a href=&quot;#是什么&quot; class=&quot;headerlink&quot; title=&quot;是什么&quot;&gt;&lt;/a&gt;是什么&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;广义上来说&lt;br&gt;是构建和运行软件时不需要关心服务器的一种架构思想。虽然 Serverless 翻译过来是 “无服
      
    
    </summary>
    
    
    
      <category term="serverless" scheme="https://feidom-up.github.io/tags/serverless/"/>
    
  </entry>
  
  <entry>
    <title>React面向组件跨层级通信</title>
    <link href="https://feidom-up.github.io/2020/12/31/React%E9%9D%A2%E5%90%91%E7%BB%84%E4%BB%B6%E8%B7%A8%E5%B1%82%E7%BA%A7%E9%80%9A%E4%BF%A1/"/>
    <id>https://feidom-up.github.io/2020/12/31/React%E9%9D%A2%E5%90%91%E7%BB%84%E4%BB%B6%E8%B7%A8%E5%B1%82%E7%BA%A7%E9%80%9A%E4%BF%A1/</id>
    <published>2020-12-31T09:13:02.000Z</published>
    <updated>2021-05-06T02:46:51.784Z</updated>
    
    <content type="html"><![CDATA[<h4 id="父与子"><a href="#父与子" class="headerlink" title="父与子"></a>父与子</h4><pre><code>父组件包裹子组件，父组件向子组件传递数据。</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子 </span></span><br><span class="line"><span class="keyword">const</span> Button = <span class="function">(<span class="params">&#123; text &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    &lt;button type=<span class="string">"button"</span>&gt;&#123;text&#125;&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 父</span></span><br><span class="line"><span class="regexp">class HomePage extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">state = &#123;</span></span><br><span class="line"><span class="regexp">    text: "默认文案"</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">asyc componentDidMount() &#123;</span></span><br><span class="line"><span class="regexp">    const response = await fetch('/</span>api/buttonText<span class="string">')</span></span><br><span class="line"><span class="string">    this.setState(&#123;</span></span><br><span class="line"><span class="string">    text: response.buttoText</span></span><br><span class="line"><span class="string">    &#125;)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">    render() &#123;</span></span><br><span class="line"><span class="string">        const &#123;</span></span><br><span class="line"><span class="string">        text</span></span><br><span class="line"><span class="string">        &#125; = this.state</span></span><br><span class="line"><span class="string">        return (</span></span><br><span class="line"><span class="string">            &lt;Button text=&#123;text&#125; /&gt;</span></span><br><span class="line"><span class="string">        )</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>这样的通信方式非常适用于展示组件。</p><h4 id="子与父"><a href="#子与父" class="headerlink" title="子与父"></a>子与父</h4><pre><code>子组件存在于父组件之中，子组件需要向父组件传递数据。</code></pre><ul><li>回调函数（主要方式）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FetchPosts</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        loading: <span class="literal">true</span>,</span><br><span class="line">        data: []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">async</span> componentDidMount() &#123;</span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">'/api/posts'</span>)</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            data: response.data,</span><br><span class="line">            loading: <span class="literal">false</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.state.loading) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Loading</span> /&gt;</span></span>  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.props.renderPosts(<span class="keyword">this</span>.state.data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePage</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">        &lt;FetchPosts</span><br><span class="line">            renderPosts=&#123;posts =&gt; (</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &#123;posts.map(<span class="function"><span class="params">post</span> =&gt;</span> (</span><br><span class="line">                &lt;li key=&#123;post.id&#125;&gt;</span><br><span class="line">                    &lt;h2&gt;&#123;post.title&#125;&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">                    &lt;p&gt;&#123;post.description&#125;&lt;/</span>p&gt;</span><br><span class="line">                &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">                    ))&#125;</span></span><br><span class="line"><span class="regexp">                &lt;/u</span>l&gt;</span><br><span class="line">            )&#125;</span><br><span class="line">        /&gt;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>实例函数（不符合 React 的设计理念，不被推荐）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePage</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">   modalRef = React.createRef()  <span class="comment">//实例</span></span><br><span class="line">   showModal = () =&#123;</span><br><span class="line">     <span class="keyword">this</span>.modalRef.show()</span><br><span class="line">   &#125;</span><br><span class="line">   hideModal = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">this</span>.modalRef.hide()</span><br><span class="line">   &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;</span><br><span class="line">          text</span><br><span class="line">        &#125; = <span class="keyword">this</span>.state</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;&gt;</span><br><span class="line">              &lt;Button onClick=&#123;<span class="keyword">this</span>.showModal&#125;&gt;展示 Modal &lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">              &lt;Button onClick=&#123;this.hideModal&#125;&gt;隐藏 Modal &lt;/</span>Button&gt;</span><br><span class="line">              &lt;Modal ref=&#123;modalRef&#125; /&gt;</span><br><span class="line">            &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">          /</span>&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="兄弟"><a href="#兄弟" class="headerlink" title="兄弟"></a>兄弟</h4><p>  两个组件并列存在于父组件中，数据需要进行相互传递，往往依赖共同的父组件进行中转。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Input</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    handleChanged = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.onChangeText(e.target.text)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;handleTextChanged&#125;</span> /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子</span></span><br><span class="line"><span class="keyword">const</span> StaticText = <span class="function">(<span class="params">&#123; children &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;P&gt;&#123;children&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 父</span></span><br><span class="line"><span class="regexp">class HomePage extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">    state = &#123;</span></span><br><span class="line"><span class="regexp">        text: '默认文案'</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    handleTextChanged = (text) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">        this.setState(&#123;</span></span><br><span class="line"><span class="regexp">        text,</span></span><br><span class="line"><span class="regexp">        &#125;)</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    render() &#123;</span></span><br><span class="line"><span class="regexp">        return (</span></span><br><span class="line"><span class="regexp">            &lt;&gt;</span></span><br><span class="line"><span class="regexp">              &lt;Input onChangeText=&#123;this.handleTextChanged&#125; /</span>&gt;</span><br><span class="line">              &lt;StaticText&gt;<span class="keyword">this</span>.state.text&lt;<span class="regexp">/StaticText&gt; </span></span><br><span class="line"><span class="regexp">            &lt;/</span>&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="无直接关系"><a href="#无直接关系" class="headerlink" title="无直接关系"></a>无直接关系</h4><p>  两个组件并没有直接的关联关系，处在一棵树中相距甚远的位置，但需要共享、传递数据。</p></li><li><p>Context<br>  Context 第一个最常见的用途就是做 i18n</p><ol><li>i18n使用Context <code>I18nContext</code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>  &#123; createContext &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">const</span> I18nContext = createContext(&#123;</span><br><span class="line">    translate: <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">''</span>,</span><br><span class="line">    getLocale: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;,</span><br><span class="line">    setLocale: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> I18nContext;</span><br></pre></td></tr></table></figure></li><li>用<code>I18nContext</code>封装个组件<code>I18nProvider</code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> I18nContext <span class="keyword">from</span> <span class="string">'./I18nContext'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">I18nProvider</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        locale: <span class="string">''</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">const</span> i18n =  &#123;</span><br><span class="line">            translate: <span class="function"><span class="params">key</span> =&gt;</span> <span class="keyword">this</span>.props.languages[locale][key],</span><br><span class="line">            getLocale: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.state.locale,</span><br><span class="line">            setLocale: <span class="function"><span class="params">locale</span> =&gt;</span> <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">                loacal,</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;I18nContext.Provider value=&#123;i18n&#125;&gt;</span><br><span class="line">                &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">            &lt;<span class="regexp">/I18nContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default I18nProvider;</span></span><br></pre></td></tr></table></figure></li><li>用<code>I18nContext</code>实现高阶组件<code>withI18n</code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> I18nContext <span class="keyword">from</span> <span class="string">'./I18nContext'</span>;</span><br><span class="line"><span class="keyword">const</span> withI18n = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">WrappedComponent</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params">props</span>) =&gt;</span> (</span><br><span class="line">        &lt;I18nContext.Consumer&gt;</span><br><span class="line">            &#123;i18n =&gt; <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...i18n</span>&#125; &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>&#125;</span><br><span class="line">        &lt;<span class="regexp">/I18nContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">export default withI18n;</span></span><br></pre></td></tr></table></figure></li><li>在最顶层注入 Provider<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; I18nProvider &#125; <span class="keyword">from</span> <span class="string">'./i18n'</span>;</span><br><span class="line"><span class="keyword">const</span> locales = [ <span class="string">'en-US'</span>, <span class="string">'zh-CN'</span> ];</span><br><span class="line"><span class="keyword">const</span> languages = &#123;</span><br><span class="line">    <span class="string">'en-US'</span>: <span class="built_in">require</span>(<span class="string">'./locales/en-US'</span>),</span><br><span class="line">    <span class="string">'zh-CN'</span>: <span class="built_in">require</span>(<span class="string">'./locales/zh-CN'</span>),</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;I18nProvider locales=&#123;locales&#125; languages=&#123;languages&#125;&gt;</span><br><span class="line">        &lt;App /&gt;</span><br><span class="line">    &lt;<span class="regexp">/I18nProvider&gt;,</span></span><br><span class="line"><span class="regexp">    document.getElementById('root')</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure></li><li>在需要的地方使用<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Title = withI18n(</span><br><span class="line">    (&#123; translate &#125;) =&gt; &#123; </span><br><span class="line">        <span class="keyword">return</span> ( <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;translate('title')&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> )</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> Footer = withI18n(</span><br><span class="line">    (&#123; setLocale &#125;) =&gt; &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params"> &lt;Button onClick=((</span>) =&gt;</span> &#123;</span><br><span class="line">            setLocale(<span class="string">'zh-CN'</span>)</span><br><span class="line">        &#125;) /&gt; )</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ol></li><li><p>全局变量<br>  全局变量，顾名思义就是放在 Window 上的变量。但值得注意的是修改 Window 上的变量并不会引起 React 组件重新渲染。</p></li><li><p>状态管理框架</p><ul><li>Flux</li><li>Redux</li><li>Mobx</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;父与子&quot;&gt;&lt;a href=&quot;#父与子&quot; class=&quot;headerlink&quot; title=&quot;父与子&quot;&gt;&lt;/a&gt;父与子&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;父组件包裹子组件，父组件向子组件传递数据。&lt;/code&gt;&lt;/pre&gt;&lt;figure class=&quot;highlight
      
    
    </summary>
    
    
      <category term="react" scheme="https://feidom-up.github.io/categories/react/"/>
    
    
      <category term="react" scheme="https://feidom-up.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>如何设计react组件</title>
    <link href="https://feidom-up.github.io/2020/12/29/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1react%E7%BB%84%E4%BB%B6/"/>
    <id>https://feidom-up.github.io/2020/12/29/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1react%E7%BB%84%E4%BB%B6/</id>
    <published>2020-12-29T11:33:19.000Z</published>
    <updated>2021-05-06T02:46:51.789Z</updated>
    
    <content type="html"><![CDATA[<h4 id="痛定思痛"><a href="#痛定思痛" class="headerlink" title="痛定思痛"></a>痛定思痛</h4><p>没有很好的设计模式，写代码将会凌乱无序。没有模块划分，也没有组合的思想。</p><ul><li>把一个页面写成一个组件</li><li>一个组件有3000行代码</li></ul><h4 id="基于场景的设计分类"><a href="#基于场景的设计分类" class="headerlink" title="基于场景的设计分类"></a>基于场景的设计分类</h4><p>围绕“如何组合”根据不同的场景设计不同模式</p><ul><li><p>组件的类别</p><ul><li><p>无状态组件/哑组件/展示组件： 只做展示、独立运行、不额外增加功能的组件</p><ul><li>优点： <ul><li>展示组件的复用性更强，复用率更高</li><li>内部没有任何的state，只受制于外部的props传参</li></ul></li><li>衍生出的其他组件设计<ul><li>代理组件：基于ui框架的其他组件，外面封装一层，实现代理组件。<ol><li>更换ui框架时更方便。解决了组件库的强依赖特性，实现无痛切换</li><li>都内聚在代理组件中，修改基础组件的属性更方便，不会散落在各处</li></ol></li><li>样式组件：本质上也是一种代理组件，但是又细分了处理样式的领域，将当前的关注点分离在组件内<ol><li>自身承接业务判断逻辑，封装了ui库中的组件来控制样式，改动会更方便更友好</li></ol></li><li>布局组件： 基本设计与样式组件完全一样，增加了一个小优化<ol><li>布局组件一般不根据状态改变，所以可以封装布局组件后，可以直接使用<code>shouldComponentUpdate</code>函数阻断渲染，提升性能</li></ol></li></ul></li></ul></li><li><p>有状态组件/灵巧组件： 处理业务逻辑与数据状态的组件<br>  灵巧组件更专注于业务本身；灵巧组件一定要至少包含一个灵巧组件或展示组件。功能更丰富，但复用率低</p><ul><li>衍生出的其他组件设计<ul><li>容器组件：几乎没有复用性，主要功能在<strong>拉取数据</strong>和<strong>组合组件</strong> </li><li>高阶组件： React中复用组件的高级技术，基于React组合特性形成的设计模式<ol><li>道理类似函数式编程的高级函数（接收一个函数，返回一个函数），高阶组件接收参数为组件，返回值也是新一个组件。</li><li>可抽取公共逻辑<ul><li>登陆态的判断<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 装饰器</span></span><br><span class="line"><span class="keyword">const</span> checkLogin = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !!localStorage.getItem(<span class="string">'token'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 装饰器写法</span></span><br><span class="line">@checkLogin</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserPage</span> <span class="keyword">extends</span>  <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">@checkLogin</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderPage</span> <span class="keyword">extends</span>  <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 高阶函数</span></span><br><span class="line"><span class="keyword">const</span> checkLogin = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> checkLogin() ? <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span> : <span class="xml"><span class="tag">&lt;<span class="name">LoginPage</span> /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RawUserPage</span> <span class="keyword">extends</span>  <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> UserPage = checkLogin(RawUserPage)</span><br></pre></td></tr></table></figure></li><li>页面埋点统计<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> trackPageView = (pageName) = &#123; </span><br><span class="line">    <span class="comment">// 发送埋点信息请求</span></span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> PV = <span class="function">(<span class="params">pageName</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrap</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">        componentDidMount() &#123;</span><br><span class="line">            trackPageView(pageName)</span><br><span class="line">        &#125;</span><br><span class="line">        render() &#123;</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">            &lt;WrappedComponent &#123;...this.props&#125; /&gt;</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">@PV(<span class="string">'用户页面'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserPage</span> <span class="keyword">extends</span>  <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">@PV(<span class="string">'购物车页面'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CartPage</span> <span class="keyword">extends</span>  <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">@PV(<span class="string">'订单页面'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderPage</span> <span class="keyword">extends</span>  <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>既要判断登陆态，又要埋点：<strong>链式调用</strong><br>  链式调用是函数式编程高级函数的一种使用场景。在链式调用后，装饰器会按照从外向内、从上往下的顺序进行执行。  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数调用方式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RawUserPage</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> UserPage = checkLogin(PV(<span class="string">'用户页面'</span>)(RawUserPage))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装饰器调用方式</span></span><br><span class="line"></span><br><span class="line">@checkLogin</span><br><span class="line">@PV(<span class="string">'用户页面'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserPage</span> <span class="keyword">extends</span>  <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>渲染劫持<br> 渲染劫持可以通过控制 render 函数修改输出内容，常见的场景是显示加载元素 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withLoading</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">        render() &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.props.isLoading) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Loading</span> /&gt;</span></span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.render();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 通过高阶函数中继承原组件的方式，劫持修改 render 函数，篡改返回修改，达到显示 Loading 的效果。</li></ol></li><li>高阶组件的缺点<ul><li>丢失静态函数：由于被包裹了一层，所以静态函数在外层是无法获取的。  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UserPage.jsx</span></span><br><span class="line">@PV(<span class="string">'用户页面'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">UserPage</span> <span class="keyword">extends</span>  <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> getUser() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// page.js</span></span><br><span class="line"><span class="keyword">import</span> UserPage <span class="keyword">from</span> <span class="string">'./UserPage'</span></span><br><span class="line">UserPage.checkLogin() <span class="comment">// 调用失败，并不存在。</span></span><br></pre></td></tr></table></figure>  <em>解决方案</em>：在外部函数中把内部函数的方法复制出来：<code>hoist-non-react-statics</code>(现成的库)  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hoistNonReactStatics <span class="keyword">from</span> <span class="string">'hoist-non-react-statics'</span>;</span><br><span class="line"><span class="keyword">const</span> PV = <span class="function">(<span class="params">pageName</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Wrap</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">            componentDidMount() &#123;</span><br><span class="line">                trackPageView(pageName)</span><br><span class="line">            &#125;</span><br><span class="line">            render() &#123;</span><br><span class="line">                <span class="keyword">return</span> (</span><br><span class="line">                &lt;WrappedComponent &#123;...this.props&#125; /&gt;</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        hoistNonReactStatics(Wrap, WrappedComponent);</span><br><span class="line">        <span class="keyword">return</span> Wrap;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>refs 属性不能透传: ref 属性由于被高阶组件包裹了一次，所以需要进行特殊处理才能获取。React 为我们提供了一个名为 React.forwardRef 的 API 来解决这一问题，以下是官方文档中的一个案例：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withLog</span>(<span class="params">Component</span>) </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LogProps</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">            componentDidUpdate(prevProps) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'old props:'</span>, prevProps);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'new props:'</span>, <span class="keyword">this</span>.props);</span><br><span class="line">        &#125;</span><br><span class="line">        render() &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123;forwardedRef, ...rest&#125; = <span class="keyword">this</span>.props;</span><br><span class="line">            <span class="comment">// 将自定义的 prop 属性 “forwardedRef” 定义为 ref</span></span><br><span class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component</span> <span class="attr">ref</span>=<span class="string">&#123;forwardedRef&#125;</span> &#123;<span class="attr">...rest</span>&#125; /&gt;</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意 React.forwardRef 回调的第二个参数 “ref”。</span></span><br><span class="line">    <span class="comment">// 我们可以将其作为常规 prop 属性传递给 LogProps，例如 “forwardedRef”</span></span><br><span class="line">    <span class="comment">// 然后它就可以被挂载到被 LogProps 包裹的子组件上。</span></span><br><span class="line">    <span class="keyword">return</span> React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">LogProps</span> &#123;<span class="attr">...props</span>&#125; <span class="attr">forwardedRef</span>=<span class="string">&#123;ref&#125;</span> /&gt;</span></span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这段代码读起来会有点儿头皮发麻，它正确的阅读顺序应该是从最底下的 React.forwardRef 部分开始，通过 forwardedRef 转发 ref 到 LogProps 内部。</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li></ul></li></ul><h4 id="所以：组件的目录结构"><a href="#所以：组件的目录结构" class="headerlink" title="所以：组件的目录结构"></a>所以：组件的目录结构</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过目录级别完成切分</span></span><br><span class="line">    src</span><br><span class="line">    ├── components</span><br><span class="line">    │   ├── basic   <span class="comment">// 最基本的展示组件放入 basic 目录中 建议使用类似 Storybook 的工具进行组件管理。</span></span><br><span class="line">    │   ├── container  <span class="comment">//将容器组件放入 container</span></span><br><span class="line">    │   └── hoc  <span class="comment">//高阶组件放入 hoc 中</span></span><br><span class="line">    └── pages  <span class="comment">//将页面外层组件放在页面目录中</span></span><br></pre></td></tr></table></figure><blockquote><p><a class="link"   href="https://storybook.js.org/"  target="_blank" rel="noopener">Storybook官网<i class="fas fa-external-link-alt"></i></a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;痛定思痛&quot;&gt;&lt;a href=&quot;#痛定思痛&quot; class=&quot;headerlink&quot; title=&quot;痛定思痛&quot;&gt;&lt;/a&gt;痛定思痛&lt;/h4&gt;&lt;p&gt;没有很好的设计模式，写代码将会凌乱无序。没有模块划分，也没有组合的思想。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把一个页面写成一个组件&lt;
      
    
    </summary>
    
    
      <category term="react" scheme="https://feidom-up.github.io/categories/react/"/>
    
    
      <category term="react" scheme="https://feidom-up.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>react的类组件和函数组件</title>
    <link href="https://feidom-up.github.io/2020/12/29/react%E7%9A%84%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%92%8C%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6/"/>
    <id>https://feidom-up.github.io/2020/12/29/react%E7%9A%84%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%92%8C%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6/</id>
    <published>2020-12-29T11:01:39.000Z</published>
    <updated>2021-05-06T02:46:51.786Z</updated>
    
    <content type="html"><![CDATA[<p>react的最小单位是组件</p><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><ul><li>实际用途是一样的，都可作为基础组件展示UI</li><li>在现代浏览器中，除极端场景下，类（类组件）和闭包（函数组件）的性能差异不大</li></ul><h4 id="区别点"><a href="#区别点" class="headerlink" title="区别点"></a>区别点</h4><ul><li>代码实现思想<ul><li>类组件的根基是OOP，面向对象编程</li><li>函数组件的根据是FP，函数式编程</li></ul></li><li>使用场景<ul><li>类组件使用生命周期</li><li>函数组件使用react hooks实现类似生命周期的能力</li></ul></li><li>设计模式<ul><li>类组件可以实现继承</li><li>函数组件缺少继承能力<blockquote><p>react前端思想：组合优于继承（继承的灵活性差，细节屏蔽过多）</p></blockquote></li></ul></li><li>性能优化<ul><li>类组件依靠<code>shouldComponentUpdate</code>函数阻断渲染</li><li>函数组件依靠<code>React.memo()</code>来优化<blockquote><p>React.memo 并不是阻断渲染，而是跳过渲染组件的操作并直接复用最近一次渲染的结果，这与 shouldComponentUpdate 是完全不同的。</p></blockquote></li></ul></li><li>未来趋势<ul><li>基于hooks的加持，react社区主推<strong>函数组件</strong></li></ul></li></ul><h4 id="优劣性"><a href="#优劣性" class="headerlink" title="优劣性"></a>优劣性</h4><ul><li>类组件<ul><li>this的模糊性</li><li>业务逻辑散落在生命周期中</li><li>类组件缺乏标准的拆分方式</li></ul></li><li>函数组件<ul><li>基于函数式编程的优点（输入输出恒定，无副作用等），函数组件更纯粹、简单、易测试。</li><li>闭包捕获的值优于this的模糊性，捕获的值永远是确定且安全的</li><li>更细腻的逻辑组织和复用，更好的作用于时间切片与并发模式</li><li>由于函数组件的执行从来都是自顶向下，依赖于<code>dom diff</code>算法不至于频繁渲染</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;react的最小单位是组件&lt;/p&gt;
&lt;h4 id=&quot;相同点&quot;&gt;&lt;a href=&quot;#相同点&quot; class=&quot;headerlink&quot; title=&quot;相同点&quot;&gt;&lt;/a&gt;相同点&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;实际用途是一样的，都可作为基础组件展示UI&lt;/li&gt;
&lt;li&gt;在现代浏览器中，
      
    
    </summary>
    
    
      <category term="react" scheme="https://feidom-up.github.io/categories/react/"/>
    
    
      <category term="react" scheme="https://feidom-up.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>react生命周期爬坑</title>
    <link href="https://feidom-up.github.io/2020/12/28/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%88%AC%E5%9D%91/"/>
    <id>https://feidom-up.github.io/2020/12/28/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%88%AC%E5%9D%91/</id>
    <published>2020-12-28T11:43:41.000Z</published>
    <updated>2021-05-06T02:46:51.786Z</updated>
    
    <content type="html"><![CDATA[<p>由于函数式组件会从头执行到尾，所以生命周期一定是在谈论类组件</p><h3 id="梳理生命周期的时机和职责，建立时机与操作的对应关系"><a href="#梳理生命周期的时机和职责，建立时机与操作的对应关系" class="headerlink" title="梳理生命周期的时机和职责，建立时机与操作的对应关系"></a>梳理生命周期的<strong>时机</strong>和<strong>职责</strong>，建立时机与操作的对应关系</h3><ul><li>使用方式（时机梳理）： 挂载，更新，卸载</li><li>适用范围（职责梳理）：状态变更、错误处理</li></ul><h4 id="时机梳理"><a href="#时机梳理" class="headerlink" title="时机梳理"></a>时机梳理</h4><h5 id="挂载阶段"><a href="#挂载阶段" class="headerlink" title="挂载阶段"></a>挂载阶段</h5><pre><code>挂载阶段是指组件从初始化到完成加载的过程。</code></pre><ul><li><p>constructor<br>  是类通用的构造函数，常用于初始化。所以在过去，constructor 通常用于初始化 state 与绑定函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Com</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">   <span class="comment">// constructor react 官方弃用</span></span><br><span class="line">   <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">      <span class="keyword">super</span>(props)   </span><br><span class="line">      <span class="keyword">this</span>.state = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>getDerivedStateFromProps</p><ul><li>当props被传入</li><li>state发生变化时</li><li>fouceUpdate被调用<blockquote><p>最常见的一个错误是认为只有 props 发生变化时，getDerivedStateFromProps 才会被调用，而实际上只要父级组件重新渲染时，getDerivedStateFromProps 就会被调用。所以是外部参数，也就是 props 传入时就会发生变化。你可能不需要使用派生 state</p></blockquote></li></ul></li><li><p>UNSAFE_componentWillMount(componentWillMount)<br>  用于组件加载前做某些操作<br>  因在React的异步渲染机制下，会被多次调用。react弃用<br>  eg：同构时，在服务器端和客户端同时发起请求拉取数据，会分别被执行一次</p></li><li><p>render 纯函数  返回jsx解构，描述渲染内容</p></li><li><p>componentDidMount<br>  组件加载完成时做某些操作，用于发起请求</p></li></ul><h5 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h5><pre><code>更新阶段是指外部 props 传入，或者 state 发生变化时的阶段。</code></pre><ul><li><p>UNSAFE_componentWillReceiveProps<br>  被标记弃用，因为其功能可被函数 getDerivedStateFromProps 所替代。</p></li><li><p>getDerivedStateFromProps<br>  同挂载阶段的表现一致。</p></li><li><p>shouldComponentUpdate<br>  该方法通过返回 true 或者 false 来确定是否需要触发新的渲染。因为渲染触发最后一道关卡，所以也是性能优化的必争之地。通过添加判断条件来阻止不必要的渲染。</p><p>  React 官方提供了一个通用的优化方案，也就是 PureComponent。PureComponent 的核心原理就是默认实现了shouldComponentUpdate函数，在这个函数中对 props 和 state 进行浅比较，用来判断是否触发更新。 </p></li><li><p>UNSAFE_componentWillUpdate<br>  同样已废弃，因为后续的 React 异步渲染设计中，可能会出现组件暂停更新渲染的情况。</p></li><li><p>render<br>  同挂载阶段的表现一致。</p></li><li><p>getSnapshotBeforeUpdate<br>  getSnapshotBeforeUpdate 方法是配合 React 新的异步渲染的机制，在 DOM 更新发生前被调用，返回值将作为 componentDidUpdate 的第三个参数。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScrollingList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.listRef = React.createRef();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    getSnapshotBeforeUpdate(prevProps, prevState) &#123;</span><br><span class="line">        <span class="comment">// Are we adding new items to the list?</span></span><br><span class="line">        <span class="comment">// Capture the scroll position so we can adjust scroll later.</span></span><br><span class="line">        <span class="keyword">if</span> (prevProps.list.length &lt; <span class="keyword">this</span>.props.list.length) &#123;</span><br><span class="line">            <span class="keyword">const</span> list = <span class="keyword">this</span>.listRef.current;</span><br><span class="line">            <span class="keyword">return</span> list.scrollHeight - list.scrollTop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    componentDidUpdate(prevProps, prevState, snapshot) &#123;</span><br><span class="line">        <span class="comment">// If we have a snapshot value, we've just added new items.</span></span><br><span class="line">        <span class="comment">// Adjust scroll so these new items don't push the old ones out of view.</span></span><br><span class="line">        <span class="comment">// (snapshot here is the value returned from getSnapshotBeforeUpdate)</span></span><br><span class="line">        <span class="keyword">if</span> (snapshot !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> list = <span class="keyword">this</span>.listRef.current;</span><br><span class="line">            list.scrollTop = list.scrollHeight - snapshot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div ref=&#123;<span class="keyword">this</span>.listRef&#125;&gt;&#123;<span class="comment">/* ...contents... */</span>&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>componentDidUpdate<br>  正如上面的案例，getSnapshotBeforeUpdate 的返回值会作为componentDidUpdate的第三个参数使用。</p></li></ul><h5 id="卸载阶段"><a href="#卸载阶段" class="headerlink" title="卸载阶段"></a>卸载阶段</h5><ul><li>componentWillUnmount<br>  卸载阶段唯一的回调函数。<br>  该函数主要用于执行清理工作。一个比较常见的 Bug 就是忘记在 componentWillUnmount 中取消定时器，导致定时操作依然在组件销毁后不停地执行。所以一定要在该阶段解除事件绑定，取消定时器。</li></ul><h4 id="职责梳理"><a href="#职责梳理" class="headerlink" title="职责梳理"></a>职责梳理</h4><p>如果我们的 React 应用足够复杂、渲染层级足够深时，一次重新渲染，将会消耗非常高的性能，导致卡顿等问题。<br>关键点：</p><ol><li>什么情况下会触发重新渲染。</li><li>渲染中发生报错后会怎样？又该如何处理？</li></ol><hr><ul><li>函数组件</li></ul><p>函数组件任何情况下都会重新渲染。<br>官方提供了一种方式优化手段，那就是 React.memo。<br>React.memo 并不是阻断渲染，而是跳过渲染组件的操作并直接复用最近一次渲染的结果，这与 shouldComponentUpdate 是完全不同的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyComponent = React.memo(<span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* 使用 props 渲染 */</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><p>React.Component<br>  如果不实现 shouldComponentUpdate 函数，那么有两种情况触发重新渲染。</p><ol><li>当 state 发生变化时。这个很好理解，是常见的情况。</li><li>当父级组件的 Props 传入时。无论 Props 有没有变化，只要传入就会引发重新渲染。</li></ol></li><li><p>React.PureComponent<br>  PureComponent 默认实现了 shouldComponentUpdate 函数。所以仅在 props 与 state 进行浅比较后，确认有变更时才会触发重新渲染。</p></li><li><p>错误边界<br>错误边界是一种 React 组件，这种组件可以捕获并打印发生在其子组件树任何位置的 JavaScript 错误，并且，它会渲染出备用 UI，如下 React 官方所给的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">hasError</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromError(error) &#123;</span><br><span class="line">    <span class="comment">// 更新 state 使下一次渲染能够显示降级后的 UI</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidCatch(error, errorInfo) &#123;</span><br><span class="line">    <span class="comment">// 你同样可以将错误日志上报给服务器</span></span><br><span class="line">    logErrorToMyService(error, errorInfo);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.hasError) &#123;</span><br><span class="line">      <span class="comment">// 你可以自定义降级后的 UI 并渲染</span></span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Something went wrong.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论是 React，还是 React Native，如果没有错误边界，在用户侧看到的现象会是这样的：在执行某个操作时，触发了 Bug，引发了崩溃，页面突然白屏。<br>但渲染时的报错，只能通过 componentDidCatch 捕获。这是在做线上页面报错监控时，极其容易忽略的点儿。</p></li></ul><h4 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h4><ul><li>在不恰当的时机调用不合适的代码</li><li>在需要调用时，忘记了调用</li></ul><p>以下情况容易造成生命周期的坑</p><ol><li><p>getDerivedStateFromProps 容易编写反模式代码，使受控组件与非受控组件区分模糊。</p></li><li><p>componentWillMount 在 React 中已被标记弃用，不推荐使用，主要原因是新的异步渲染架构会导致它被多次调用。所以网络请求及事件绑定代码应移至 componentDidMount 中。</p></li><li><p>componentWillReceiveProps 同样被标记弃用，被 getDerivedStateFromProps 所取代，主要原因是性能问题。</p></li><li><p>shouldComponentUpdate 通过返回 true 或者 false 来确定是否需要触发新的渲染。主要用于性能优化。</p></li><li><p>componentWillUpdate 同样是由于新的异步渲染机制，而被标记废弃，不推荐使用，原先的逻辑可结合 getSnapshotBeforeUpdate 与 componentDidUpdate 改造使用。</p></li><li><p>如果在 componentWillUnmount 函数中忘记解除事件绑定，取消定时器等清理操作，容易引发 bug。</p></li><li><p>如果没有添加错误边界处理，当渲染发生异常时，用户将会看到一个无法操作的白屏，所以一定要添加。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于函数式组件会从头执行到尾，所以生命周期一定是在谈论类组件&lt;/p&gt;
&lt;h3 id=&quot;梳理生命周期的时机和职责，建立时机与操作的对应关系&quot;&gt;&lt;a href=&quot;#梳理生命周期的时机和职责，建立时机与操作的对应关系&quot; class=&quot;headerlink&quot; title=&quot;梳理生命
      
    
    </summary>
    
    
      <category term="react" scheme="https://feidom-up.github.io/categories/react/"/>
    
    
      <category term="react" scheme="https://feidom-up.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>你可能不需要使用派生state</title>
    <link href="https://feidom-up.github.io/2020/12/28/%E4%BD%A0%E5%8F%AF%E8%83%BD%E4%B8%8D%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%B4%BE%E7%94%9Fstate/"/>
    <id>https://feidom-up.github.io/2020/12/28/%E4%BD%A0%E5%8F%AF%E8%83%BD%E4%B8%8D%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%B4%BE%E7%94%9Fstate/</id>
    <published>2020-12-28T09:14:17.000Z</published>
    <updated>2021-05-06T02:46:51.789Z</updated>
    
    <content type="html"><![CDATA[<p><a class="link"   href="https://zh-hans.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html"  target="_blank" rel="noopener">你可能不需要使用派生state<i class="fas fa-external-link-alt"></i></a></p><p>文中列举了两种反模式的使用方式</p><ul><li>直接复制prop到state</li><li>在props变化后修改state</li></ul><p>这两种使用方式除了增加代码的维护成本外，没有任何的好处</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a class=&quot;link&quot;   href=&quot;https://zh-hans.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html&quot;  target=&quot;_blank&quot; rel=&quot;noop
      
    
    </summary>
    
    
      <category term="react" scheme="https://feidom-up.github.io/categories/react/"/>
    
    
      <category term="react" scheme="https://feidom-up.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>webpack优化之代码分割splitChunck</title>
    <link href="https://feidom-up.github.io/2020/12/21/webpack%E4%BC%98%E5%8C%96%E4%B9%8B%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2/"/>
    <id>https://feidom-up.github.io/2020/12/21/webpack%E4%BC%98%E5%8C%96%E4%B9%8B%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2/</id>
    <published>2020-12-21T06:06:00.000Z</published>
    <updated>2021-05-06T02:46:51.789Z</updated>
    
    <content type="html"><![CDATA[<h4 id="代码分割"><a href="#代码分割" class="headerlink" title="代码分割"></a>代码分割</h4><ul><li>splitChunck</li><li>动态引用<ul><li>适用场景：抽离相同代码到一个共享块</li><li>脚本懒加载，使得初始下载代码更小</li></ul></li><li>懒加载JS脚本方式<ul><li>CommonJS: require.ensure</li><li>ES6: 动态import（需要babel支持，@babel/plugin-syntax-dynamic-import)</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置.babelrc</span></span><br><span class="line"><span class="string">"plugins"</span>: [</span><br><span class="line">    [<span class="string">"@babel/plugin-syntax-dynamic-import"</span>],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>dist代码通过window[‘webpackJsonp’]来获取对应脚本</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;代码分割&quot;&gt;&lt;a href=&quot;#代码分割&quot; class=&quot;headerlink&quot; title=&quot;代码分割&quot;&gt;&lt;/a&gt;代码分割&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;splitChunck&lt;/li&gt;
&lt;li&gt;动态引用&lt;ul&gt;
&lt;li&gt;适用场景：抽离相同代码到一个共享块&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="webpack" scheme="https://feidom-up.github.io/categories/webpack/"/>
    
    
      <category term="前端工程化" scheme="https://feidom-up.github.io/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
      <category term="webpack" scheme="https://feidom-up.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack优化之Scope Hoisting</title>
    <link href="https://feidom-up.github.io/2020/12/21/webpack%E4%BC%98%E5%8C%96%E4%B9%8BScopeHoisting/"/>
    <id>https://feidom-up.github.io/2020/12/21/webpack%E4%BC%98%E5%8C%96%E4%B9%8BScopeHoisting/</id>
    <published>2020-12-21T05:58:20.000Z</published>
    <updated>2021-05-06T02:46:51.789Z</updated>
    
    <content type="html"><![CDATA[<h4 id="webpack打包现象"><a href="#webpack打包现象" class="headerlink" title="webpack打包现象"></a>webpack打包现象</h4><p>webpack构建后的代码存在大量的闭包代码</p><ul><li>大量函数闭包包裹代码，导致体积增大(模块越多越明显)</li><li>运行代码时创建的函数作用域变多，内存开销变大</li><li>被webpack转换后的模块会带上一层包裹，import会被转换成<strong>webpack_require</strong></li></ul><h4 id="Scope-Hoisting原理"><a href="#Scope-Hoisting原理" class="headerlink" title="Scope Hoisting原理"></a>Scope Hoisting原理</h4><ul><li>将所有模块的代码按照引用顺序放在一个函数作用域中，然后适当的重命名一些变量以防止变量名冲突</li><li>对比，通过scope hoisting 可以减少函数声明代码和内存开销</li></ul><h4 id="开启scope-hoisting"><a href="#开启scope-hoisting" class="headerlink" title="开启scope hoisting"></a>开启scope hoisting</h4><ul><li>webpack4 mode 为 production默认开启，必须是ES6语法，commonJS不支持</li><li>webpack3 增加插件 new webpack.optimize.ModuleConcatenationPlugin()</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;webpack打包现象&quot;&gt;&lt;a href=&quot;#webpack打包现象&quot; class=&quot;headerlink&quot; title=&quot;webpack打包现象&quot;&gt;&lt;/a&gt;webpack打包现象&lt;/h4&gt;&lt;p&gt;webpack构建后的代码存在大量的闭包代码&lt;/p&gt;
&lt;ul&gt;
&lt;l
      
    
    </summary>
    
    
      <category term="webpack" scheme="https://feidom-up.github.io/categories/webpack/"/>
    
    
      <category term="前端工程化" scheme="https://feidom-up.github.io/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
      <category term="webpack" scheme="https://feidom-up.github.io/tags/webpack/"/>
    
  </entry>
  
</feed>
