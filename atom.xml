<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>feidom up up up</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://feidom-up.github.io/"/>
  <updated>2021-05-28T02:15:59.420Z</updated>
  <id>https://feidom-up.github.io/</id>
  
  <author>
    <name>乔文飞</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>webpackPlugins</title>
    <link href="https://feidom-up.github.io/2021/05/28/webpackPlugins/"/>
    <id>https://feidom-up.github.io/2021/05/28/webpackPlugins/</id>
    <published>2021-05-28T02:07:55.000Z</published>
    <updated>2021-05-28T02:15:59.420Z</updated>
    
    <content type="html"><![CDATA[<h4 id="webpack-DefinePlugin"><a href="#webpack-DefinePlugin" class="headerlink" title="webpack.DefinePlugin"></a>webpack.DefinePlugin</h4><ul><li>简介<br>在编译时创建一个可以配置的全局变量，在区分开发模式｜生产模式的不同时十分有用。</li><li>使用：<ul><li>在webpack的plugins中，增加<code>webpack.DefinePlugin(Object)</code>的实例</li><li>方法中传入的Object的key值，可以在项目所有import的文件中使用。</li><li>使用时得到的是key对应额value，这里在编译时，并不是变量的引用，而是<strong>编译时直接替换</strong><blockquote><p>因为这个插件直接执行文本替换，给定的值必须包含字符串本身内的实际引号。通常，有两种方式来达到这个效果，使用 ‘“production”‘, 或者使用 JSON.stringify(‘production’)。</p></blockquote></li></ul></li><li>文档地址<ul><li><a class="link"   href="https://v4.webpack.docschina.org/plugins/define-plugin/"  target="_blank" rel="noopener">webpack.DefinePlugin<i class="fas fa-external-link-alt"></i></a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;webpack-DefinePlugin&quot;&gt;&lt;a href=&quot;#webpack-DefinePlugin&quot; class=&quot;headerlink&quot; title=&quot;webpack.DefinePlugin&quot;&gt;&lt;/a&gt;webpack.DefinePlugin&lt;/h4&gt;&lt;
      
    
    </summary>
    
    
      <category term="webpack" scheme="https://feidom-up.github.io/categories/webpack/"/>
    
    
      <category term="前端工程化" scheme="https://feidom-up.github.io/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
      <category term="webpack" scheme="https://feidom-up.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>vue3的数据响应式系统</title>
    <link href="https://feidom-up.github.io/2021/03/19/vue3%E7%9A%84%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    <id>https://feidom-up.github.io/2021/03/19/vue3%E7%9A%84%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-03-19T07:54:57.000Z</published>
    <updated>2021-05-06T02:46:51.787Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Vue2-0的数据监听"><a href="#Vue2-0的数据监听" class="headerlink" title="Vue2.0的数据监听"></a>Vue2.0的数据监听</h3><p><strong>Object.defineProperty</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(object1, <span class="string">'property1'</span>, &#123;</span><br><span class="line">    value: <span class="number">42</span>,</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    <span class="keyword">get</span>()&#123;&#125;,</span><br><span class="line">    <span class="keyword">set</span>(newValue) &#123; bValue = newValue; &#125;,</span><br><span class="line">    enumerable : <span class="literal">true</span>,</span><br><span class="line">    configurable : <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">object1.property1 = <span class="number">77</span>;</span><br><span class="line"><span class="comment">// throws an error in strict mode</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(object1.property1);</span><br><span class="line"><span class="comment">// expected output: 42</span></span><br></pre></td></tr></table></figure><h3 id="Vue3-0的数据响应式系统"><a href="#Vue3-0的数据响应式系统" class="headerlink" title="Vue3.0的数据响应式系统"></a>Vue3.0的数据响应式系统</h3><p><strong>proxy</strong> get\set</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用vue-next(3)源码中'packages/reactivity/dist/reactivity.global.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;reactive, effect&#125; = VueObserver;</span><br><span class="line"><span class="comment">//  reactive: 把数据处理成为响应式数据</span></span><br><span class="line"><span class="comment">//  effect: </span></span><br><span class="line"><span class="comment">//      1.首先会执行一次对应的监听函数</span></span><br><span class="line"><span class="comment">//      2.修改对应监听函数内使用的响应式数据，对应的监听函数就会立即执行，重新执行的过程就会获取新的数据</span></span><br><span class="line"><span class="keyword">const</span> yideng = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> state = reactive(yideng);</span><br><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> count = state.count;</span><br><span class="line">    <span class="keyword">const</span>.log(<span class="string">'当前的count'</span>, count)</span><br><span class="line">    <span class="comment">//render(count)  如果在这触发render渲染</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">effect(fn)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Vue2-0的数据监听&quot;&gt;&lt;a href=&quot;#Vue2-0的数据监听&quot; class=&quot;headerlink&quot; title=&quot;Vue2.0的数据监听&quot;&gt;&lt;/a&gt;Vue2.0的数据监听&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Object.defineProperty&lt;/str
      
    
    </summary>
    
    
      <category term="vue" scheme="https://feidom-up.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="https://feidom-up.github.io/tags/vue/"/>
    
      <category term="vue源码解读" scheme="https://feidom-up.github.io/tags/vue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法之队列</title>
    <link href="https://feidom-up.github.io/2021/03/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%98%9F%E5%88%97/"/>
    <id>https://feidom-up.github.io/2021/03/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%98%9F%E5%88%97/</id>
    <published>2021-03-17T10:44:26.000Z</published>
    <updated>2021-05-06T02:46:51.790Z</updated>
    
    <content type="html"><![CDATA[<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul><li>特性：先进先出</li><li>解题法则：<ul><li>题目具备<strong>广度遍历（分层遍历）</strong>和<strong>顺序输出</strong>的特点，就应该想到用FIFO 队列来试一试。</li><li><strong>滑动窗口</strong>类型题</li></ul></li><li>模板：<ul><li>分层遍历</li><li>循环队列</li><li>单调队列</li></ul></li></ul><hr><h5 id="普通队列"><a href="#普通队列" class="headerlink" title="普通队列"></a>普通队列</h5><ul><li>例题1：从上到下按层打印二叉树，同一层结点按从左到右的顺序打印，每一层打印到一行。<br>  输入： <pre><code>   39     8    6   7</code></pre>  输出：<code>[[3], [9, 8], [6, 7]]</code></li></ul><p><strong>二叉树的层次遍历</strong>的解题技巧</p><ul><li>遍历方式的变化：<ul><li>二叉树的锯齿形遍历</li><li>二叉树层次倒序遍历</li></ul></li><li>层的信息变化<ul><li>二叉树的层平均值</li><li>二叉树最深层的叶节点的和</li><li>二叉树的最大宽度</li></ul></li><li>树的变化<ul><li>N叉树的层次遍历</li><li>N叉树的最大深度</li></ul></li></ul><hr><h5 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h5><ul><li>重点： 循环使用固定空间</li><li>难点： 控制好 front/rear 两个首尾指示器</li><li>空队列和满队列的判断，在于<code>used</code>变量</li><li>例题2：设计一个可以容纳 k 个元素的循环队列。需要实现以下接口：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参数k表示这个循环队列最多只能容纳k个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCircularQueue</span><span class="params">(<span class="keyword">int</span> k)</span></span>;</span><br><span class="line">    <span class="comment">// 将value放到队列中, 成功返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line">    <span class="comment">// 删除队首元素，成功返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deQueue</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 得到队首元素，如果为空，返回-1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Front</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 得到队尾元素，如果队列为空，返回-1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Rear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 看一下循环队列是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 看一下循环队列是否已放满k个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h5><ul><li>概念： 要求队列中的元素必须满足单调性，比如<strong>单调递增</strong>，或者<strong>单调递减</strong>。单调队列属于双端队列的一种。双端队列与 FIFO 队列的区别在于：<ul><li>FIFO 队列只能从尾部添加元素，首部弹出元素；</li><li>双端队列可以从首尾两端 push/pop 元素。</li></ul></li><li>注意： 单调队列在入队的时候，需要满足 2 点：<ul><li>入队前队列已经满足单调性；</li><li>入队后队列仍然满足单调性。</li></ul></li><li>例题3：滑动窗口的最大值<br>  输入：nums = [1,3,-1,-3,5,3], k = 3<br>  输出：[3,3,5,5]<blockquote><p>符合<font color=red>单调递减队列！</font></p></blockquote></li><li>例题4： 给定一个数组 A[]，每个位置 i 放置了金币 A[i]，小明从 A[0] 出发。当小明走到 A[i] 的时候，下一步他可以选择 A[i+1, i+k]（当然，不能超出数组边界）。每个位置一旦被选择，将会把那个位置的金币收走（如果为负数，就要交出金币）。请问，最多能收集多少金币？<br>  输入：[1,-1,-100,-1000,100,3], k = 2<br>  输出：4<br>  解释：从 A[0] = 1 出发，收获金币 1。下一步走往 A[2] = -100, 收获金币 -100。再下一步走到 A[4] = 100，收获金币 100，最后走到 A[5] = 3，收获金币 3。最多收获 1 - 100 + 100 + 3 = 4。没有比这个更好的走法了。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;队列&quot;&gt;&lt;a href=&quot;#队列&quot; class=&quot;headerlink&quot; title=&quot;队列&quot;&gt;&lt;/a&gt;队列&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;特性：先进先出&lt;/li&gt;
&lt;li&gt;解题法则：&lt;ul&gt;
&lt;li&gt;题目具备&lt;strong&gt;广度遍历（分层遍历）&lt;/strong&gt;和&lt;
      
    
    </summary>
    
    
      <category term="算法" scheme="https://feidom-up.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="https://feidom-up.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://feidom-up.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="队列" scheme="https://feidom-up.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>手写代码系列之New(fn)</title>
    <link href="https://feidom-up.github.io/2021/03/17/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%B3%BB%E5%88%97%E4%B9%8BNew-fn/"/>
    <id>https://feidom-up.github.io/2021/03/17/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%B3%BB%E5%88%97%E4%B9%8BNew-fn/</id>
    <published>2021-03-17T00:46:47.000Z</published>
    <updated>2021-05-06T02:46:51.789Z</updated>
    
    <content type="html"><![CDATA[<h3 id="New操作符做了哪些事"><a href="#New操作符做了哪些事" class="headerlink" title="New操作符做了哪些事"></a>New操作符做了哪些事</h3><ul><li>创建了一个全新的对象。</li><li>会被执行[[Prototype]]（也就是<strong>proto</strong>）链接。</li><li>使this指向新创建的对象。</li><li>通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上。</li><li>如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用将返回该对象引用。</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li><p>版本一：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个对象，且将其隐式原型指向构造函数原型</span></span><br><span class="line">        <span class="keyword">let</span> obj = &#123;</span><br><span class="line">            __proto__: fn.prototype</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行构造函数</span></span><br><span class="line">        fn.call(obj, ...arguments)</span><br><span class="line">        <span class="comment">// 返回该对象</span></span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = myNew(Person)(<span class="string">'chen'</span>, <span class="number">18</span>)</span><br></pre></td></tr></table></figure></li><li><p>版本二：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span>(fn.prototype !==<span class="literal">null</span>)&#123;</span><br><span class="line">        res.__proto__ = fn.prototype;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> ret = fn.apply(res, <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> ret === <span class="string">"object"</span> || <span class="keyword">typeof</span> ret === <span class="string">"function"</span>) &amp;&amp; ret !== <span class="literal">null</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用示例：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> obj = New(A, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// equals to</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> A(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;New操作符做了哪些事&quot;&gt;&lt;a href=&quot;#New操作符做了哪些事&quot; class=&quot;headerlink&quot; title=&quot;New操作符做了哪些事&quot;&gt;&lt;/a&gt;New操作符做了哪些事&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;创建了一个全新的对象。&lt;/li&gt;
&lt;li&gt;会被执行[[P
      
    
    </summary>
    
    
      <category term="手写代码系列" scheme="https://feidom-up.github.io/categories/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>手写代码系列之防抖与节流</title>
    <link href="https://feidom-up.github.io/2021/03/16/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%B3%BB%E5%88%97%E4%B9%8B%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"/>
    <id>https://feidom-up.github.io/2021/03/16/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%B3%BB%E5%88%97%E4%B9%8B%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</id>
    <published>2021-03-16T07:26:28.000Z</published>
    <updated>2021-05-06T02:46:51.790Z</updated>
    
    <content type="html"><![CDATA[<h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p><strong>思路</strong>：在规定时间内未触发第二次，则执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 利用闭包保存定时器</span></span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="comment">// 在规定时间内再次触发</span></span><br><span class="line">        <span class="comment">// 会先清除定时器再重设定时器</span></span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            fn.apply(context, args)</span><br><span class="line">        &#125;,delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用举例：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"防抖"</span>)</span><br><span class="line">&#125;</span><br><span class="line">addEventListener(<span class="string">"scroll"</span>, debounce(fn1, <span class="number">1000</span>))</span><br></pre></td></tr></table></figure><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p><strong>思路</strong>：在规定时间内只触发一次</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 利用闭包保存时间</span></span><br><span class="line">    <span class="keyword">let</span> prev = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">let</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="keyword">if</span>(now - prev &gt;= delay)&#123;</span><br><span class="line">            fn.apply(context, args);</span><br><span class="line">            prev = <span class="built_in">Date</span>.now();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用举例：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"节流"</span>)</span><br><span class="line">&#125;</span><br><span class="line">addEventListener(<span class="string">"scroll"</span>, throttle(fn2, <span class="number">1000</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;防抖&quot;&gt;&lt;a href=&quot;#防抖&quot; class=&quot;headerlink&quot; title=&quot;防抖&quot;&gt;&lt;/a&gt;防抖&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;：在规定时间内未触发第二次，则执行&lt;/p&gt;
&lt;figure class=&quot;highlight java
      
    
    </summary>
    
    
      <category term="手写代码系列" scheme="https://feidom-up.github.io/categories/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>手写代码咔咔咔</title>
    <link href="https://feidom-up.github.io/2021/03/16/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E5%92%94%E5%92%94%E5%92%94/"/>
    <id>https://feidom-up.github.io/2021/03/16/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E5%92%94%E5%92%94%E5%92%94/</id>
    <published>2021-03-16T07:24:51.000Z</published>
    <updated>2021-05-06T02:46:51.789Z</updated>
    
    <content type="html"><![CDATA[<h3 id="咔咔咔"><a href="#咔咔咔" class="headerlink" title="咔咔咔"></a>咔咔咔</h3><ul><li><a href="/2021/03/16/手写代码系列之防抖与节流/">手写代码系列之防抖与节流</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;咔咔咔&quot;&gt;&lt;a href=&quot;#咔咔咔&quot; class=&quot;headerlink&quot; title=&quot;咔咔咔&quot;&gt;&lt;/a&gt;咔咔咔&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2021/03/16/手写代码系列之防抖与节流/&quot;&gt;手写代码系列之防抖与节流&lt;/a&gt;&lt;/li&gt;
&lt;/
      
    
    </summary>
    
    
      <category term="手写代码系列" scheme="https://feidom-up.github.io/categories/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法之栈结构</title>
    <link href="https://feidom-up.github.io/2021/03/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A0%88%E7%BB%93%E6%9E%84/"/>
    <id>https://feidom-up.github.io/2021/03/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A0%88%E7%BB%93%E6%9E%84/</id>
    <published>2021-03-16T07:15:17.000Z</published>
    <updated>2021-05-06T02:46:51.790Z</updated>
    
    <content type="html"><![CDATA[<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul><li>特性：先进后出</li><li>解题法则：<ul><li>题目中有<strong>配对、消除</strong>的题意，优先考虑<strong>栈</strong>结构</li><li>栈中存放的可以是<strong>内容本身</strong>和<strong>内容的索引</strong></li><li>数组中右边<strong>第一个比我小</strong>的元素的位置，求解用<strong>递增栈</strong></li><li>较小的数<strong>消除</strong>掉较大的数的时候，使用<strong>递增栈</strong>。</li><li>根据题意总结<strong>入栈与出栈的时机</strong></li></ul></li></ul><h5 id="普通栈"><a href="#普通栈" class="headerlink" title="普通栈"></a>普通栈</h5><ul><li>规律性：<font color=red>配对、消除</font></li></ul><hr><ul><li>例题1：字符串中只有字符’(‘和’)’。合法字符串需要括号可以配对。比如：<br>  输入：”()”<br>  输出：true<br>  解释：()，()()，(())是合法的。)(，()(，(()是非法的。<br>  请你实现一个函数<code>isValid(s)</code>，来判断给定的字符串是否合法。<blockquote><p>针对例1这种<font color=green>内容一样</font>时，可以使用<font color=green>计数器优化</font></p></blockquote></li><li>例题拓展： 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。有效字符串需满足：<br>  左括号必须用相同类型的右括号闭合<br>  左括号必须以正确的顺序闭合<br>  注意空字符串可被认为是有效字符串<br>  请实现<code>isValid(s)</code></li></ul><hr><ul><li>例题2：在水中有许多鱼，可以认为这些鱼停放在 x 轴上。再给定两个数组 Size，Dir，Size[i] 表示第 i 条鱼的大小，Dir[i] 表示鱼的方向 （0 表示向左游，1 表示向右游）。这两个数组分别表示鱼的大小和游动的方向，并且两个数组的长度相等。鱼的行为符合以下几个条件:<br>  所有的鱼都同时开始游动，每次按照鱼的方向，都游动一个单位距离；<br>  当方向相对时，大鱼会吃掉小鱼；<br>  鱼的大小都不一样。<br>  输入：Size = [4, 2, 5, 3, 1], Dir = [1, 1, 0, 0, 0]<br>  输出：3<br>  完成<code>solution(Size, Dir)</code>来计算还剩下几条鱼？</li></ul><hr><h5 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h5><ul><li>定义：单调栈就是指栈中的元素必须是按照升序排列的栈，或者是降序排列的栈。<br>  升序排列的栈称为<strong>递增栈</strong><br>  降序排列的栈称为<strong>递减栈</strong><br>  特点：任何时候都需要保证栈的有序性</li></ul><hr><ul><li>例题1：一个整数数组 A，找到每个元素：右边第一个比我小的下标位置，没有则用 -1 表示。（找出数组中右边比我小的元素）<br>  输入：[5, 2]<br>  输出：[1, -1]<br>  解释：因为元素 5 的右边离我最近且比我小的位置应该是 A[1]，最后一个元素 2 右边没有比 2 小的元素，所以应该输出 -1。</li></ul><blockquote><p>类似题：<br>数组中右边第一个比我大的元素的位置<br>数组中元素左边离我最近且比我小的元素的位置<br>数组中元素左边离我最近且比我大的元素的位置</p></blockquote><ul><li>例题2：给定一个正整数数组和 k，要求依次取出 k 个数，输出其中数组的一个子序列，需要满足：1. 长度为 k；2.字典序最小。<br>  输入：nums = [3,5,2,6], k = 2<br>  输出：[2,6]<br>  解释：在所有可能的解：{[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]} 中，[2,6] 字典序最小。</li></ul><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><p><img src="https://s0.lgstatic.com/i/image6/M01/0B/7F/CioPOWA4q6qASB-UAADhj7uzOwg933.png" alt="图"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;栈&quot;&gt;&lt;a href=&quot;#栈&quot; class=&quot;headerlink&quot; title=&quot;栈&quot;&gt;&lt;/a&gt;栈&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;特性：先进后出&lt;/li&gt;
&lt;li&gt;解题法则：&lt;ul&gt;
&lt;li&gt;题目中有&lt;strong&gt;配对、消除&lt;/strong&gt;的题意，优先考虑&lt;st
      
    
    </summary>
    
    
      <category term="算法" scheme="https://feidom-up.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="https://feidom-up.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://feidom-up.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="栈" scheme="https://feidom-up.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法</title>
    <link href="https://feidom-up.github.io/2021/03/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>https://feidom-up.github.io/2021/03/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</id>
    <published>2021-03-03T01:34:21.000Z</published>
    <updated>2021-05-06T02:46:51.790Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法四步分析法："><a href="#算法四步分析法：" class="headerlink" title="算法四步分析法："></a>算法四步分析法：</h3><ol><li>模拟：模拟题目的运行。</li><li>规律：尝试总结出题目的一般规律和特点。</li><li>匹配：找到符合这些特点的数据结构与算法。</li><li>边界：考虑特殊情况。</li></ol><h3 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h3><ul><li><a href="/2021/03/16/数据结构与算法之栈结构/">栈结构与算法</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法四步分析法：&quot;&gt;&lt;a href=&quot;#算法四步分析法：&quot; class=&quot;headerlink&quot; title=&quot;算法四步分析法：&quot;&gt;&lt;/a&gt;算法四步分析法：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;模拟：模拟题目的运行。&lt;/li&gt;
&lt;li&gt;规律：尝试总结出题目的一般规律和特点。
      
    
    </summary>
    
    
      <category term="算法" scheme="https://feidom-up.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="https://feidom-up.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://feidom-up.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Virtual DOM的工作原理</title>
    <link href="https://feidom-up.github.io/2021/01/02/%E8%99%9A%E6%8B%9Fdom/"/>
    <id>https://feidom-up.github.io/2021/01/02/%E8%99%9A%E6%8B%9Fdom/</id>
    <published>2021-01-02T15:22:41.000Z</published>
    <updated>2021-05-06T02:46:51.790Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Virtual-DOM-也被称为虚拟DOM"><a href="#Virtual-DOM-也被称为虚拟DOM" class="headerlink" title="Virtual DOM 也被称为虚拟DOM"></a>Virtual DOM 也被称为虚拟DOM</h4><ul><li>在react中，<code>jsx语法</code>经过<code>babel解析</code>转化为<code>React.createElement()</code>函数调用后生成<code>ast抽象语法树</code>，再通过<code>render</code>函数将<code>ast树</code>转换为<code>fiber 结构</code>，填入许多调度、更新、diff相关数据，并转换<code>ast树</code>为<code>虚拟DOM树</code>，再完成挂载。</li><li>在vue中，模版语法 经过 <code>generate</code>处理(正则匹配 生成 <code>ast抽象语法树</code>)，<code>render</code>中调用<code>_c()/createElement()</code>函数将<code>ast树</code>生成<code>VNode(虚拟DOM)</code>,再完成挂载。</li></ul><h4 id="虚拟DOM的来源"><a href="#虚拟DOM的来源" class="headerlink" title="虚拟DOM的来源"></a>虚拟DOM的来源</h4><p>react的前身是facebook的<code>XHP</code>，在这个框架中，页面都是通过转义的方式生成的，并没有直接的HTML，确保在<code>XHP</code>中写出安全的静态页面。</p><p>初衷是：</p><ul><li>简化前端开发（后端赋能）</li><li>防止xss攻击</li></ul><p>发展是：</p><ul><li>通过虚拟DOM规避风险，不让用户直接的操作DOM了，而是把它封起来自己管理</li></ul><h4 id="虚拟DOM的表现形式"><a href="#虚拟DOM的表现形式" class="headerlink" title="虚拟DOM的表现形式"></a>虚拟DOM的表现形式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    tag: <span class="string">'input'</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">        type: <span class="string">'button'</span>,</span><br><span class="line">        value: <span class="string">''</span></span><br><span class="line">    &#125;,</span><br><span class="line">    childrean: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>React 有两个函数<br>    * diff 函数，去计算状态变更前后的虚拟 DOM 树差异<br>    * 渲染函数，渲染整个虚拟 DOM 树或者处理差异点。<br>    现在是不是有些理解为什么 React 与 ReactDOM 是两个库了？正是由于计算与渲染的分工。<br>    其中 React 的主要工作是组件实现、更新调度；ReactDOM 提供了在 网页上渲染 的基础</p></blockquote><h4 id="虚拟DOM的优缺点"><a href="#虚拟DOM的优缺点" class="headerlink" title="虚拟DOM的优缺点"></a>虚拟DOM的优缺点</h4><p>优点</p><ul><li>性能优越</li><li>规避XSS</li><li>可跨平台</li></ul><p>但是不是所有的操作都是虚拟DOM更高效<br>&emsp;&emsp;大量的直接操作DOM容易引起页面性能下降。这时React基于虚拟DOM的diff处理与批处理操作，可降低DOM的操作频次和范围，提升页面性能<br>&emsp;&emsp;但是在首次渲染或者微量dom操作的时候，虚拟DOM的性能就更慢一些。</p><p>那虚拟 DOM 一定可以规避 XSS吗？<br>&emsp;&emsp;虚拟 DOM 内部确保了字符转义，所以确实可以做到这点，但 React 存在风险，因为 React 留有 dangerouslySetInnerHTML API 绕过转义。</p><p>没有虚拟 DOM 不能实现跨平台吗？<br>&emsp;&emsp;比如 NativeScript 没有虚拟 DOM 层 ，它是通过提供兼容原生 API 的 JS API 实现跨平台开发。<br>那虚拟 DOM 的优势在哪里？<br>&emsp;&emsp;实际上它的优势在于跨平台的成本更低。在 React Native 之后，前端社区从虚拟 DOM 中体会到了跨平台的无限前景，<br>所以在后续的发展中，都借鉴了虚拟 DOM。比如：社区流行的小程序同构方案，在构建过程中会提供类似虚拟 DOM 的结构描述对象，来支撑多端转换。</p><p>缺点</p><ul><li>内存占用较高</li><li>难以进行优化</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Virtual-DOM-也被称为虚拟DOM&quot;&gt;&lt;a href=&quot;#Virtual-DOM-也被称为虚拟DOM&quot; class=&quot;headerlink&quot; title=&quot;Virtual DOM 也被称为虚拟DOM&quot;&gt;&lt;/a&gt;Virtual DOM 也被称为虚拟DOM&lt;/
      
    
    </summary>
    
    
      <category term="react" scheme="https://feidom-up.github.io/categories/react/"/>
    
      <category term="vue" scheme="https://feidom-up.github.io/categories/react/vue/"/>
    
    
      <category term="react" scheme="https://feidom-up.github.io/tags/react/"/>
    
      <category term="vue" scheme="https://feidom-up.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Serverless是什么</title>
    <link href="https://feidom-up.github.io/2021/01/01/Serverless%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>https://feidom-up.github.io/2021/01/01/Serverless%E6%98%AF%E4%BB%80%E4%B9%88/</id>
    <published>2021-01-01T13:59:56.000Z</published>
    <updated>2021-05-06T02:46:51.785Z</updated>
    
    <content type="html"><![CDATA[<h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><ul><li><p>广义上来说<br>是构建和运行软件时不需要关心服务器的一种架构思想。虽然 Serverless 翻译过来是 “无服务器”，但这并不代表着应用运行不需要服务器，而是开发者不需要关心服务器。而基于 Serverless 思想实现的软件架构就是 Serverless 架构。</p></li><li><p>狭义上说<br>  狭义的 Serverless 是 <code>FaaS</code> 和 <code>BaaS</code> 的组合。</p><ul><li>FaaS（Function as a Service）：<ol><li>FaaS本质上是一个函数运行平台，函数运行时，你对底层的服务器是无感知的，FaaS 产品会负责资源的调度和运维，这是它的特点之一，<strong>不用运维</strong>。</li><li>FaaS 中的函数也不是持续运行的，而是通过事件进行触发，比如 HTTP 事件、消息事件等，产生事件的源头叫触发器，FaaS 平台会集成这些触发器，我们直接用就行，这是 FaaS 的第二个特点，<strong>事件驱动</strong>。</li><li>FaaS 的第三个特点是<strong>按量付费</strong>。 FaaS 产品的收费方式，都是按照函数执行次数和执行时消耗的 CPU、内存等资源进行计费的。</li><li>FaaS 在运行函数的时候，会根据并发量自动生成多个函数实例，并且并发理论是没有上限的，这是它的第四个特点，<strong>弹性伸缩</strong>。</li></ol><ul><li>FaaS 每次执行函数时，都会初始化一个新的运行环境，然后从头开始执行整个代码，而不是只执行其中的 handler 方法。执行完毕后，运行环境就会被释放。这样每次函数执行，都是新的运行环境，自然不同函数之间就无法共用 pv 这个变量了。FaaS 的另一个特点，<strong>无状态</strong>。</li></ul></li><li>BaaS（Backend as a Service）<br> 为了解决分布式中的状态共享问题<br> BaaS 本质上就是把后端功能封装起来，以接口的形式提供服务。</li></ul></li><li><p>总<br>基于 FaaS 和 BaaS 的架构，是一种计算和存储分离的架构。 计算由 FaaS 负责，存储由 BaaS 负责，计算和存储也被分开部署和收费。这使应用的存储不再是应用本身的一部分，而是演变成了独立的云服务，降低了数据丢失的风险。而应用本身也变成了无状态的应用，更容易进行调度和扩缩容。</p></li></ul><p>基于 FaaS 和 BaaS ，你的应用就实现了自动弹性伸缩、按量付费、不用关心服务器，这正是 Serverless 架构的必要因素。所以说狭义的 Serverless 是 FaaS 和 BaaS 的组合。</p><h3 id="与其他架构的区别"><a href="#与其他架构的区别" class="headerlink" title="与其他架构的区别"></a>与其他架构的区别</h3><ul><li>PaaS<br>  PaaS （平台即服务）是云计算虚拟机时代的主要形态之一。 它是指云厂商提供开发工具、依赖库、服务和运行平台等能力，开发者可以依赖这些能力将自己的应用直接部署在云平台上，不用关心底层的计算资源、网络、存储等。虽然与Serverless 很类似，但依旧存在一些区别。</li><li>Kubernetes<br>  Kubernetes 是一种容器编排技术。在 Kubernetes 中应用运行的基本单位是 Pod（容器组），Pod 是应用及运行环境的集合，所以你也不用关心服务器了。基于 Kubernetes，你能很方便地进行 Pod 的管理，并且实现应用的弹性伸缩。<br>  所以，Kubernetes 是介于 Serverful 和 Serverless 中间的产物。</li></ul><p><strong>Serverless 是云原生的一种实现，云原生的另一种实现是 Kubernetes。</strong></p><table><thead><tr><th align="left">Serverless</th><th align="left">PaaS （平台即服务）</th><th align="left">Kubernetes</th></tr></thead><tbody><tr><td align="left">按实际使用量付费</td><td align="left">按资源付费</td><td align="left">按照资源数量计费</td></tr></tbody></table><h3 id="Serverless-的优缺点"><a href="#Serverless-的优缺点" class="headerlink" title="Serverless 的优缺点"></a>Serverless 的优缺点</h3><ul><li>优点：不用运维、弹性伸缩、节省成本、开发简单、降低风险、易于扩展。</li><li>缺点：<ol><li>依赖第三方服务：一旦你选择了一个云厂商，要想从一个云移到另一个台，成本很高</li><li>底层硬件的多样性：代码依赖的地层硬件多样性</li><li>应用性能瓶颈：函数运行前需要现初始化函数运行环境，这个过程需要消耗一定时间。因为函数不是持续“在线”的，而是需要运行的时候才启动（不像传统应用，服务是一直启动的）。</li><li>函数通信效率低：在 Serverless 应用中，函数与函数之间就完全独立了。如果两个函数的数据有依赖，需要进行通信、交换数据，就要进行函数与函数之间的调用（调用方式是 HTTP 调用）。相比之前的内存调用，数据交互效率显然低了很多。而这个问题的本质，是 FaaS 还没有比较好的数据通信协议或方案。</li><li>开发调试复杂：Serverless 架构正处于飞速发展的阶段，其开发、调试、部署工具链并不完善（基本是每个云厂商各玩各的）</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;是什么&quot;&gt;&lt;a href=&quot;#是什么&quot; class=&quot;headerlink&quot; title=&quot;是什么&quot;&gt;&lt;/a&gt;是什么&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;广义上来说&lt;br&gt;是构建和运行软件时不需要关心服务器的一种架构思想。虽然 Serverless 翻译过来是 “无服
      
    
    </summary>
    
    
    
      <category term="serverless" scheme="https://feidom-up.github.io/tags/serverless/"/>
    
  </entry>
  
  <entry>
    <title>React面向组件跨层级通信</title>
    <link href="https://feidom-up.github.io/2020/12/31/React%E9%9D%A2%E5%90%91%E7%BB%84%E4%BB%B6%E8%B7%A8%E5%B1%82%E7%BA%A7%E9%80%9A%E4%BF%A1/"/>
    <id>https://feidom-up.github.io/2020/12/31/React%E9%9D%A2%E5%90%91%E7%BB%84%E4%BB%B6%E8%B7%A8%E5%B1%82%E7%BA%A7%E9%80%9A%E4%BF%A1/</id>
    <published>2020-12-31T09:13:02.000Z</published>
    <updated>2021-05-06T02:46:51.784Z</updated>
    
    <content type="html"><![CDATA[<h4 id="父与子"><a href="#父与子" class="headerlink" title="父与子"></a>父与子</h4><pre><code>父组件包裹子组件，父组件向子组件传递数据。</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子 </span></span><br><span class="line"><span class="keyword">const</span> Button = <span class="function">(<span class="params">&#123; text &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    &lt;button type=<span class="string">"button"</span>&gt;&#123;text&#125;&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 父</span></span><br><span class="line"><span class="regexp">class HomePage extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">state = &#123;</span></span><br><span class="line"><span class="regexp">    text: "默认文案"</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">asyc componentDidMount() &#123;</span></span><br><span class="line"><span class="regexp">    const response = await fetch('/</span>api/buttonText<span class="string">')</span></span><br><span class="line"><span class="string">    this.setState(&#123;</span></span><br><span class="line"><span class="string">    text: response.buttoText</span></span><br><span class="line"><span class="string">    &#125;)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">    render() &#123;</span></span><br><span class="line"><span class="string">        const &#123;</span></span><br><span class="line"><span class="string">        text</span></span><br><span class="line"><span class="string">        &#125; = this.state</span></span><br><span class="line"><span class="string">        return (</span></span><br><span class="line"><span class="string">            &lt;Button text=&#123;text&#125; /&gt;</span></span><br><span class="line"><span class="string">        )</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>这样的通信方式非常适用于展示组件。</p><h4 id="子与父"><a href="#子与父" class="headerlink" title="子与父"></a>子与父</h4><pre><code>子组件存在于父组件之中，子组件需要向父组件传递数据。</code></pre><ul><li>回调函数（主要方式）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FetchPosts</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        loading: <span class="literal">true</span>,</span><br><span class="line">        data: []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">async</span> componentDidMount() &#123;</span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">'/api/posts'</span>)</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            data: response.data,</span><br><span class="line">            loading: <span class="literal">false</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.state.loading) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Loading</span> /&gt;</span></span>  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.props.renderPosts(<span class="keyword">this</span>.state.data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePage</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">        &lt;FetchPosts</span><br><span class="line">            renderPosts=&#123;posts =&gt; (</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &#123;posts.map(<span class="function"><span class="params">post</span> =&gt;</span> (</span><br><span class="line">                &lt;li key=&#123;post.id&#125;&gt;</span><br><span class="line">                    &lt;h2&gt;&#123;post.title&#125;&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">                    &lt;p&gt;&#123;post.description&#125;&lt;/</span>p&gt;</span><br><span class="line">                &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">                    ))&#125;</span></span><br><span class="line"><span class="regexp">                &lt;/u</span>l&gt;</span><br><span class="line">            )&#125;</span><br><span class="line">        /&gt;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>实例函数（不符合 React 的设计理念，不被推荐）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePage</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">   modalRef = React.createRef()  <span class="comment">//实例</span></span><br><span class="line">   showModal = () =&#123;</span><br><span class="line">     <span class="keyword">this</span>.modalRef.show()</span><br><span class="line">   &#125;</span><br><span class="line">   hideModal = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">this</span>.modalRef.hide()</span><br><span class="line">   &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;</span><br><span class="line">          text</span><br><span class="line">        &#125; = <span class="keyword">this</span>.state</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;&gt;</span><br><span class="line">              &lt;Button onClick=&#123;<span class="keyword">this</span>.showModal&#125;&gt;展示 Modal &lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">              &lt;Button onClick=&#123;this.hideModal&#125;&gt;隐藏 Modal &lt;/</span>Button&gt;</span><br><span class="line">              &lt;Modal ref=&#123;modalRef&#125; /&gt;</span><br><span class="line">            &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">          /</span>&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="兄弟"><a href="#兄弟" class="headerlink" title="兄弟"></a>兄弟</h4><p>  两个组件并列存在于父组件中，数据需要进行相互传递，往往依赖共同的父组件进行中转。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Input</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    handleChanged = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.onChangeText(e.target.text)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;handleTextChanged&#125;</span> /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子</span></span><br><span class="line"><span class="keyword">const</span> StaticText = <span class="function">(<span class="params">&#123; children &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;P&gt;&#123;children&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 父</span></span><br><span class="line"><span class="regexp">class HomePage extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">    state = &#123;</span></span><br><span class="line"><span class="regexp">        text: '默认文案'</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    handleTextChanged = (text) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">        this.setState(&#123;</span></span><br><span class="line"><span class="regexp">        text,</span></span><br><span class="line"><span class="regexp">        &#125;)</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    render() &#123;</span></span><br><span class="line"><span class="regexp">        return (</span></span><br><span class="line"><span class="regexp">            &lt;&gt;</span></span><br><span class="line"><span class="regexp">              &lt;Input onChangeText=&#123;this.handleTextChanged&#125; /</span>&gt;</span><br><span class="line">              &lt;StaticText&gt;<span class="keyword">this</span>.state.text&lt;<span class="regexp">/StaticText&gt; </span></span><br><span class="line"><span class="regexp">            &lt;/</span>&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="无直接关系"><a href="#无直接关系" class="headerlink" title="无直接关系"></a>无直接关系</h4><p>  两个组件并没有直接的关联关系，处在一棵树中相距甚远的位置，但需要共享、传递数据。</p></li><li><p>Context<br>  Context 第一个最常见的用途就是做 i18n</p><ol><li>i18n使用Context <code>I18nContext</code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>  &#123; createContext &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">const</span> I18nContext = createContext(&#123;</span><br><span class="line">    translate: <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">''</span>,</span><br><span class="line">    getLocale: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;,</span><br><span class="line">    setLocale: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> I18nContext;</span><br></pre></td></tr></table></figure></li><li>用<code>I18nContext</code>封装个组件<code>I18nProvider</code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> I18nContext <span class="keyword">from</span> <span class="string">'./I18nContext'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">I18nProvider</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        locale: <span class="string">''</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">const</span> i18n =  &#123;</span><br><span class="line">            translate: <span class="function"><span class="params">key</span> =&gt;</span> <span class="keyword">this</span>.props.languages[locale][key],</span><br><span class="line">            getLocale: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.state.locale,</span><br><span class="line">            setLocale: <span class="function"><span class="params">locale</span> =&gt;</span> <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">                loacal,</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;I18nContext.Provider value=&#123;i18n&#125;&gt;</span><br><span class="line">                &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">            &lt;<span class="regexp">/I18nContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default I18nProvider;</span></span><br></pre></td></tr></table></figure></li><li>用<code>I18nContext</code>实现高阶组件<code>withI18n</code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> I18nContext <span class="keyword">from</span> <span class="string">'./I18nContext'</span>;</span><br><span class="line"><span class="keyword">const</span> withI18n = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">WrappedComponent</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params">props</span>) =&gt;</span> (</span><br><span class="line">        &lt;I18nContext.Consumer&gt;</span><br><span class="line">            &#123;i18n =&gt; <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...i18n</span>&#125; &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>&#125;</span><br><span class="line">        &lt;<span class="regexp">/I18nContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">export default withI18n;</span></span><br></pre></td></tr></table></figure></li><li>在最顶层注入 Provider<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; I18nProvider &#125; <span class="keyword">from</span> <span class="string">'./i18n'</span>;</span><br><span class="line"><span class="keyword">const</span> locales = [ <span class="string">'en-US'</span>, <span class="string">'zh-CN'</span> ];</span><br><span class="line"><span class="keyword">const</span> languages = &#123;</span><br><span class="line">    <span class="string">'en-US'</span>: <span class="built_in">require</span>(<span class="string">'./locales/en-US'</span>),</span><br><span class="line">    <span class="string">'zh-CN'</span>: <span class="built_in">require</span>(<span class="string">'./locales/zh-CN'</span>),</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;I18nProvider locales=&#123;locales&#125; languages=&#123;languages&#125;&gt;</span><br><span class="line">        &lt;App /&gt;</span><br><span class="line">    &lt;<span class="regexp">/I18nProvider&gt;,</span></span><br><span class="line"><span class="regexp">    document.getElementById('root')</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure></li><li>在需要的地方使用<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Title = withI18n(</span><br><span class="line">    (&#123; translate &#125;) =&gt; &#123; </span><br><span class="line">        <span class="keyword">return</span> ( <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;translate('title')&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> )</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> Footer = withI18n(</span><br><span class="line">    (&#123; setLocale &#125;) =&gt; &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params"> &lt;Button onClick=((</span>) =&gt;</span> &#123;</span><br><span class="line">            setLocale(<span class="string">'zh-CN'</span>)</span><br><span class="line">        &#125;) /&gt; )</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ol></li><li><p>全局变量<br>  全局变量，顾名思义就是放在 Window 上的变量。但值得注意的是修改 Window 上的变量并不会引起 React 组件重新渲染。</p></li><li><p>状态管理框架</p><ul><li>Flux</li><li>Redux</li><li>Mobx</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;父与子&quot;&gt;&lt;a href=&quot;#父与子&quot; class=&quot;headerlink&quot; title=&quot;父与子&quot;&gt;&lt;/a&gt;父与子&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;父组件包裹子组件，父组件向子组件传递数据。&lt;/code&gt;&lt;/pre&gt;&lt;figure class=&quot;highlight
      
    
    </summary>
    
    
      <category term="react" scheme="https://feidom-up.github.io/categories/react/"/>
    
    
      <category term="react" scheme="https://feidom-up.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>如何设计react组件</title>
    <link href="https://feidom-up.github.io/2020/12/29/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1react%E7%BB%84%E4%BB%B6/"/>
    <id>https://feidom-up.github.io/2020/12/29/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1react%E7%BB%84%E4%BB%B6/</id>
    <published>2020-12-29T11:33:19.000Z</published>
    <updated>2021-05-06T02:46:51.789Z</updated>
    
    <content type="html"><![CDATA[<h4 id="痛定思痛"><a href="#痛定思痛" class="headerlink" title="痛定思痛"></a>痛定思痛</h4><p>没有很好的设计模式，写代码将会凌乱无序。没有模块划分，也没有组合的思想。</p><ul><li>把一个页面写成一个组件</li><li>一个组件有3000行代码</li></ul><h4 id="基于场景的设计分类"><a href="#基于场景的设计分类" class="headerlink" title="基于场景的设计分类"></a>基于场景的设计分类</h4><p>围绕“如何组合”根据不同的场景设计不同模式</p><ul><li><p>组件的类别</p><ul><li><p>无状态组件/哑组件/展示组件： 只做展示、独立运行、不额外增加功能的组件</p><ul><li>优点： <ul><li>展示组件的复用性更强，复用率更高</li><li>内部没有任何的state，只受制于外部的props传参</li></ul></li><li>衍生出的其他组件设计<ul><li>代理组件：基于ui框架的其他组件，外面封装一层，实现代理组件。<ol><li>更换ui框架时更方便。解决了组件库的强依赖特性，实现无痛切换</li><li>都内聚在代理组件中，修改基础组件的属性更方便，不会散落在各处</li></ol></li><li>样式组件：本质上也是一种代理组件，但是又细分了处理样式的领域，将当前的关注点分离在组件内<ol><li>自身承接业务判断逻辑，封装了ui库中的组件来控制样式，改动会更方便更友好</li></ol></li><li>布局组件： 基本设计与样式组件完全一样，增加了一个小优化<ol><li>布局组件一般不根据状态改变，所以可以封装布局组件后，可以直接使用<code>shouldComponentUpdate</code>函数阻断渲染，提升性能</li></ol></li></ul></li></ul></li><li><p>有状态组件/灵巧组件： 处理业务逻辑与数据状态的组件<br>  灵巧组件更专注于业务本身；灵巧组件一定要至少包含一个灵巧组件或展示组件。功能更丰富，但复用率低</p><ul><li>衍生出的其他组件设计<ul><li>容器组件：几乎没有复用性，主要功能在<strong>拉取数据</strong>和<strong>组合组件</strong> </li><li>高阶组件： React中复用组件的高级技术，基于React组合特性形成的设计模式<ol><li>道理类似函数式编程的高级函数（接收一个函数，返回一个函数），高阶组件接收参数为组件，返回值也是新一个组件。</li><li>可抽取公共逻辑<ul><li>登陆态的判断<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 装饰器</span></span><br><span class="line"><span class="keyword">const</span> checkLogin = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !!localStorage.getItem(<span class="string">'token'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 装饰器写法</span></span><br><span class="line">@checkLogin</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserPage</span> <span class="keyword">extends</span>  <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">@checkLogin</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderPage</span> <span class="keyword">extends</span>  <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 高阶函数</span></span><br><span class="line"><span class="keyword">const</span> checkLogin = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> checkLogin() ? <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span> : <span class="xml"><span class="tag">&lt;<span class="name">LoginPage</span> /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RawUserPage</span> <span class="keyword">extends</span>  <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> UserPage = checkLogin(RawUserPage)</span><br></pre></td></tr></table></figure></li><li>页面埋点统计<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> trackPageView = (pageName) = &#123; </span><br><span class="line">    <span class="comment">// 发送埋点信息请求</span></span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> PV = <span class="function">(<span class="params">pageName</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrap</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">        componentDidMount() &#123;</span><br><span class="line">            trackPageView(pageName)</span><br><span class="line">        &#125;</span><br><span class="line">        render() &#123;</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">            &lt;WrappedComponent &#123;...this.props&#125; /&gt;</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">@PV(<span class="string">'用户页面'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserPage</span> <span class="keyword">extends</span>  <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">@PV(<span class="string">'购物车页面'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CartPage</span> <span class="keyword">extends</span>  <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">@PV(<span class="string">'订单页面'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderPage</span> <span class="keyword">extends</span>  <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>既要判断登陆态，又要埋点：<strong>链式调用</strong><br>  链式调用是函数式编程高级函数的一种使用场景。在链式调用后，装饰器会按照从外向内、从上往下的顺序进行执行。  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数调用方式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RawUserPage</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> UserPage = checkLogin(PV(<span class="string">'用户页面'</span>)(RawUserPage))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装饰器调用方式</span></span><br><span class="line"></span><br><span class="line">@checkLogin</span><br><span class="line">@PV(<span class="string">'用户页面'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserPage</span> <span class="keyword">extends</span>  <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>渲染劫持<br> 渲染劫持可以通过控制 render 函数修改输出内容，常见的场景是显示加载元素 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withLoading</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">        render() &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.props.isLoading) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Loading</span> /&gt;</span></span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.render();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 通过高阶函数中继承原组件的方式，劫持修改 render 函数，篡改返回修改，达到显示 Loading 的效果。</li></ol></li><li>高阶组件的缺点<ul><li>丢失静态函数：由于被包裹了一层，所以静态函数在外层是无法获取的。  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UserPage.jsx</span></span><br><span class="line">@PV(<span class="string">'用户页面'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">UserPage</span> <span class="keyword">extends</span>  <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> getUser() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// page.js</span></span><br><span class="line"><span class="keyword">import</span> UserPage <span class="keyword">from</span> <span class="string">'./UserPage'</span></span><br><span class="line">UserPage.checkLogin() <span class="comment">// 调用失败，并不存在。</span></span><br></pre></td></tr></table></figure>  <em>解决方案</em>：在外部函数中把内部函数的方法复制出来：<code>hoist-non-react-statics</code>(现成的库)  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hoistNonReactStatics <span class="keyword">from</span> <span class="string">'hoist-non-react-statics'</span>;</span><br><span class="line"><span class="keyword">const</span> PV = <span class="function">(<span class="params">pageName</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Wrap</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">            componentDidMount() &#123;</span><br><span class="line">                trackPageView(pageName)</span><br><span class="line">            &#125;</span><br><span class="line">            render() &#123;</span><br><span class="line">                <span class="keyword">return</span> (</span><br><span class="line">                &lt;WrappedComponent &#123;...this.props&#125; /&gt;</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        hoistNonReactStatics(Wrap, WrappedComponent);</span><br><span class="line">        <span class="keyword">return</span> Wrap;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>refs 属性不能透传: ref 属性由于被高阶组件包裹了一次，所以需要进行特殊处理才能获取。React 为我们提供了一个名为 React.forwardRef 的 API 来解决这一问题，以下是官方文档中的一个案例：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withLog</span>(<span class="params">Component</span>) </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LogProps</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">            componentDidUpdate(prevProps) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'old props:'</span>, prevProps);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'new props:'</span>, <span class="keyword">this</span>.props);</span><br><span class="line">        &#125;</span><br><span class="line">        render() &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123;forwardedRef, ...rest&#125; = <span class="keyword">this</span>.props;</span><br><span class="line">            <span class="comment">// 将自定义的 prop 属性 “forwardedRef” 定义为 ref</span></span><br><span class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component</span> <span class="attr">ref</span>=<span class="string">&#123;forwardedRef&#125;</span> &#123;<span class="attr">...rest</span>&#125; /&gt;</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意 React.forwardRef 回调的第二个参数 “ref”。</span></span><br><span class="line">    <span class="comment">// 我们可以将其作为常规 prop 属性传递给 LogProps，例如 “forwardedRef”</span></span><br><span class="line">    <span class="comment">// 然后它就可以被挂载到被 LogProps 包裹的子组件上。</span></span><br><span class="line">    <span class="keyword">return</span> React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">LogProps</span> &#123;<span class="attr">...props</span>&#125; <span class="attr">forwardedRef</span>=<span class="string">&#123;ref&#125;</span> /&gt;</span></span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这段代码读起来会有点儿头皮发麻，它正确的阅读顺序应该是从最底下的 React.forwardRef 部分开始，通过 forwardedRef 转发 ref 到 LogProps 内部。</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li></ul></li></ul><h4 id="所以：组件的目录结构"><a href="#所以：组件的目录结构" class="headerlink" title="所以：组件的目录结构"></a>所以：组件的目录结构</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过目录级别完成切分</span></span><br><span class="line">    src</span><br><span class="line">    ├── components</span><br><span class="line">    │   ├── basic   <span class="comment">// 最基本的展示组件放入 basic 目录中 建议使用类似 Storybook 的工具进行组件管理。</span></span><br><span class="line">    │   ├── container  <span class="comment">//将容器组件放入 container</span></span><br><span class="line">    │   └── hoc  <span class="comment">//高阶组件放入 hoc 中</span></span><br><span class="line">    └── pages  <span class="comment">//将页面外层组件放在页面目录中</span></span><br></pre></td></tr></table></figure><blockquote><p><a class="link"   href="https://storybook.js.org/"  target="_blank" rel="noopener">Storybook官网<i class="fas fa-external-link-alt"></i></a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;痛定思痛&quot;&gt;&lt;a href=&quot;#痛定思痛&quot; class=&quot;headerlink&quot; title=&quot;痛定思痛&quot;&gt;&lt;/a&gt;痛定思痛&lt;/h4&gt;&lt;p&gt;没有很好的设计模式，写代码将会凌乱无序。没有模块划分，也没有组合的思想。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把一个页面写成一个组件&lt;
      
    
    </summary>
    
    
      <category term="react" scheme="https://feidom-up.github.io/categories/react/"/>
    
    
      <category term="react" scheme="https://feidom-up.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>react的类组件和函数组件</title>
    <link href="https://feidom-up.github.io/2020/12/29/react%E7%9A%84%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%92%8C%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6/"/>
    <id>https://feidom-up.github.io/2020/12/29/react%E7%9A%84%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%92%8C%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6/</id>
    <published>2020-12-29T11:01:39.000Z</published>
    <updated>2021-05-06T02:46:51.786Z</updated>
    
    <content type="html"><![CDATA[<p>react的最小单位是组件</p><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><ul><li>实际用途是一样的，都可作为基础组件展示UI</li><li>在现代浏览器中，除极端场景下，类（类组件）和闭包（函数组件）的性能差异不大</li></ul><h4 id="区别点"><a href="#区别点" class="headerlink" title="区别点"></a>区别点</h4><ul><li>代码实现思想<ul><li>类组件的根基是OOP，面向对象编程</li><li>函数组件的根据是FP，函数式编程</li></ul></li><li>使用场景<ul><li>类组件使用生命周期</li><li>函数组件使用react hooks实现类似生命周期的能力</li></ul></li><li>设计模式<ul><li>类组件可以实现继承</li><li>函数组件缺少继承能力<blockquote><p>react前端思想：组合优于继承（继承的灵活性差，细节屏蔽过多）</p></blockquote></li></ul></li><li>性能优化<ul><li>类组件依靠<code>shouldComponentUpdate</code>函数阻断渲染</li><li>函数组件依靠<code>React.memo()</code>来优化<blockquote><p>React.memo 并不是阻断渲染，而是跳过渲染组件的操作并直接复用最近一次渲染的结果，这与 shouldComponentUpdate 是完全不同的。</p></blockquote></li></ul></li><li>未来趋势<ul><li>基于hooks的加持，react社区主推<strong>函数组件</strong></li></ul></li></ul><h4 id="优劣性"><a href="#优劣性" class="headerlink" title="优劣性"></a>优劣性</h4><ul><li>类组件<ul><li>this的模糊性</li><li>业务逻辑散落在生命周期中</li><li>类组件缺乏标准的拆分方式</li></ul></li><li>函数组件<ul><li>基于函数式编程的优点（输入输出恒定，无副作用等），函数组件更纯粹、简单、易测试。</li><li>闭包捕获的值优于this的模糊性，捕获的值永远是确定且安全的</li><li>更细腻的逻辑组织和复用，更好的作用于时间切片与并发模式</li><li>由于函数组件的执行从来都是自顶向下，依赖于<code>dom diff</code>算法不至于频繁渲染</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;react的最小单位是组件&lt;/p&gt;
&lt;h4 id=&quot;相同点&quot;&gt;&lt;a href=&quot;#相同点&quot; class=&quot;headerlink&quot; title=&quot;相同点&quot;&gt;&lt;/a&gt;相同点&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;实际用途是一样的，都可作为基础组件展示UI&lt;/li&gt;
&lt;li&gt;在现代浏览器中，
      
    
    </summary>
    
    
      <category term="react" scheme="https://feidom-up.github.io/categories/react/"/>
    
    
      <category term="react" scheme="https://feidom-up.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>react生命周期爬坑</title>
    <link href="https://feidom-up.github.io/2020/12/28/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%88%AC%E5%9D%91/"/>
    <id>https://feidom-up.github.io/2020/12/28/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%88%AC%E5%9D%91/</id>
    <published>2020-12-28T11:43:41.000Z</published>
    <updated>2021-05-06T02:46:51.786Z</updated>
    
    <content type="html"><![CDATA[<p>由于函数式组件会从头执行到尾，所以生命周期一定是在谈论类组件</p><h3 id="梳理生命周期的时机和职责，建立时机与操作的对应关系"><a href="#梳理生命周期的时机和职责，建立时机与操作的对应关系" class="headerlink" title="梳理生命周期的时机和职责，建立时机与操作的对应关系"></a>梳理生命周期的<strong>时机</strong>和<strong>职责</strong>，建立时机与操作的对应关系</h3><ul><li>使用方式（时机梳理）： 挂载，更新，卸载</li><li>适用范围（职责梳理）：状态变更、错误处理</li></ul><h4 id="时机梳理"><a href="#时机梳理" class="headerlink" title="时机梳理"></a>时机梳理</h4><h5 id="挂载阶段"><a href="#挂载阶段" class="headerlink" title="挂载阶段"></a>挂载阶段</h5><pre><code>挂载阶段是指组件从初始化到完成加载的过程。</code></pre><ul><li><p>constructor<br>  是类通用的构造函数，常用于初始化。所以在过去，constructor 通常用于初始化 state 与绑定函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Com</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">   <span class="comment">// constructor react 官方弃用</span></span><br><span class="line">   <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">      <span class="keyword">super</span>(props)   </span><br><span class="line">      <span class="keyword">this</span>.state = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>getDerivedStateFromProps</p><ul><li>当props被传入</li><li>state发生变化时</li><li>fouceUpdate被调用<blockquote><p>最常见的一个错误是认为只有 props 发生变化时，getDerivedStateFromProps 才会被调用，而实际上只要父级组件重新渲染时，getDerivedStateFromProps 就会被调用。所以是外部参数，也就是 props 传入时就会发生变化。你可能不需要使用派生 state</p></blockquote></li></ul></li><li><p>UNSAFE_componentWillMount(componentWillMount)<br>  用于组件加载前做某些操作<br>  因在React的异步渲染机制下，会被多次调用。react弃用<br>  eg：同构时，在服务器端和客户端同时发起请求拉取数据，会分别被执行一次</p></li><li><p>render 纯函数  返回jsx解构，描述渲染内容</p></li><li><p>componentDidMount<br>  组件加载完成时做某些操作，用于发起请求</p></li></ul><h5 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h5><pre><code>更新阶段是指外部 props 传入，或者 state 发生变化时的阶段。</code></pre><ul><li><p>UNSAFE_componentWillReceiveProps<br>  被标记弃用，因为其功能可被函数 getDerivedStateFromProps 所替代。</p></li><li><p>getDerivedStateFromProps<br>  同挂载阶段的表现一致。</p></li><li><p>shouldComponentUpdate<br>  该方法通过返回 true 或者 false 来确定是否需要触发新的渲染。因为渲染触发最后一道关卡，所以也是性能优化的必争之地。通过添加判断条件来阻止不必要的渲染。</p><p>  React 官方提供了一个通用的优化方案，也就是 PureComponent。PureComponent 的核心原理就是默认实现了shouldComponentUpdate函数，在这个函数中对 props 和 state 进行浅比较，用来判断是否触发更新。 </p></li><li><p>UNSAFE_componentWillUpdate<br>  同样已废弃，因为后续的 React 异步渲染设计中，可能会出现组件暂停更新渲染的情况。</p></li><li><p>render<br>  同挂载阶段的表现一致。</p></li><li><p>getSnapshotBeforeUpdate<br>  getSnapshotBeforeUpdate 方法是配合 React 新的异步渲染的机制，在 DOM 更新发生前被调用，返回值将作为 componentDidUpdate 的第三个参数。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScrollingList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.listRef = React.createRef();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    getSnapshotBeforeUpdate(prevProps, prevState) &#123;</span><br><span class="line">        <span class="comment">// Are we adding new items to the list?</span></span><br><span class="line">        <span class="comment">// Capture the scroll position so we can adjust scroll later.</span></span><br><span class="line">        <span class="keyword">if</span> (prevProps.list.length &lt; <span class="keyword">this</span>.props.list.length) &#123;</span><br><span class="line">            <span class="keyword">const</span> list = <span class="keyword">this</span>.listRef.current;</span><br><span class="line">            <span class="keyword">return</span> list.scrollHeight - list.scrollTop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    componentDidUpdate(prevProps, prevState, snapshot) &#123;</span><br><span class="line">        <span class="comment">// If we have a snapshot value, we've just added new items.</span></span><br><span class="line">        <span class="comment">// Adjust scroll so these new items don't push the old ones out of view.</span></span><br><span class="line">        <span class="comment">// (snapshot here is the value returned from getSnapshotBeforeUpdate)</span></span><br><span class="line">        <span class="keyword">if</span> (snapshot !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> list = <span class="keyword">this</span>.listRef.current;</span><br><span class="line">            list.scrollTop = list.scrollHeight - snapshot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div ref=&#123;<span class="keyword">this</span>.listRef&#125;&gt;&#123;<span class="comment">/* ...contents... */</span>&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>componentDidUpdate<br>  正如上面的案例，getSnapshotBeforeUpdate 的返回值会作为componentDidUpdate的第三个参数使用。</p></li></ul><h5 id="卸载阶段"><a href="#卸载阶段" class="headerlink" title="卸载阶段"></a>卸载阶段</h5><ul><li>componentWillUnmount<br>  卸载阶段唯一的回调函数。<br>  该函数主要用于执行清理工作。一个比较常见的 Bug 就是忘记在 componentWillUnmount 中取消定时器，导致定时操作依然在组件销毁后不停地执行。所以一定要在该阶段解除事件绑定，取消定时器。</li></ul><h4 id="职责梳理"><a href="#职责梳理" class="headerlink" title="职责梳理"></a>职责梳理</h4><p>如果我们的 React 应用足够复杂、渲染层级足够深时，一次重新渲染，将会消耗非常高的性能，导致卡顿等问题。<br>关键点：</p><ol><li>什么情况下会触发重新渲染。</li><li>渲染中发生报错后会怎样？又该如何处理？</li></ol><hr><ul><li>函数组件</li></ul><p>函数组件任何情况下都会重新渲染。<br>官方提供了一种方式优化手段，那就是 React.memo。<br>React.memo 并不是阻断渲染，而是跳过渲染组件的操作并直接复用最近一次渲染的结果，这与 shouldComponentUpdate 是完全不同的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyComponent = React.memo(<span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* 使用 props 渲染 */</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><p>React.Component<br>  如果不实现 shouldComponentUpdate 函数，那么有两种情况触发重新渲染。</p><ol><li>当 state 发生变化时。这个很好理解，是常见的情况。</li><li>当父级组件的 Props 传入时。无论 Props 有没有变化，只要传入就会引发重新渲染。</li></ol></li><li><p>React.PureComponent<br>  PureComponent 默认实现了 shouldComponentUpdate 函数。所以仅在 props 与 state 进行浅比较后，确认有变更时才会触发重新渲染。</p></li><li><p>错误边界<br>错误边界是一种 React 组件，这种组件可以捕获并打印发生在其子组件树任何位置的 JavaScript 错误，并且，它会渲染出备用 UI，如下 React 官方所给的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">hasError</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromError(error) &#123;</span><br><span class="line">    <span class="comment">// 更新 state 使下一次渲染能够显示降级后的 UI</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidCatch(error, errorInfo) &#123;</span><br><span class="line">    <span class="comment">// 你同样可以将错误日志上报给服务器</span></span><br><span class="line">    logErrorToMyService(error, errorInfo);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.hasError) &#123;</span><br><span class="line">      <span class="comment">// 你可以自定义降级后的 UI 并渲染</span></span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Something went wrong.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论是 React，还是 React Native，如果没有错误边界，在用户侧看到的现象会是这样的：在执行某个操作时，触发了 Bug，引发了崩溃，页面突然白屏。<br>但渲染时的报错，只能通过 componentDidCatch 捕获。这是在做线上页面报错监控时，极其容易忽略的点儿。</p></li></ul><h4 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h4><ul><li>在不恰当的时机调用不合适的代码</li><li>在需要调用时，忘记了调用</li></ul><p>以下情况容易造成生命周期的坑</p><ol><li><p>getDerivedStateFromProps 容易编写反模式代码，使受控组件与非受控组件区分模糊。</p></li><li><p>componentWillMount 在 React 中已被标记弃用，不推荐使用，主要原因是新的异步渲染架构会导致它被多次调用。所以网络请求及事件绑定代码应移至 componentDidMount 中。</p></li><li><p>componentWillReceiveProps 同样被标记弃用，被 getDerivedStateFromProps 所取代，主要原因是性能问题。</p></li><li><p>shouldComponentUpdate 通过返回 true 或者 false 来确定是否需要触发新的渲染。主要用于性能优化。</p></li><li><p>componentWillUpdate 同样是由于新的异步渲染机制，而被标记废弃，不推荐使用，原先的逻辑可结合 getSnapshotBeforeUpdate 与 componentDidUpdate 改造使用。</p></li><li><p>如果在 componentWillUnmount 函数中忘记解除事件绑定，取消定时器等清理操作，容易引发 bug。</p></li><li><p>如果没有添加错误边界处理，当渲染发生异常时，用户将会看到一个无法操作的白屏，所以一定要添加。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于函数式组件会从头执行到尾，所以生命周期一定是在谈论类组件&lt;/p&gt;
&lt;h3 id=&quot;梳理生命周期的时机和职责，建立时机与操作的对应关系&quot;&gt;&lt;a href=&quot;#梳理生命周期的时机和职责，建立时机与操作的对应关系&quot; class=&quot;headerlink&quot; title=&quot;梳理生命
      
    
    </summary>
    
    
      <category term="react" scheme="https://feidom-up.github.io/categories/react/"/>
    
    
      <category term="react" scheme="https://feidom-up.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>你可能不需要使用派生state</title>
    <link href="https://feidom-up.github.io/2020/12/28/%E4%BD%A0%E5%8F%AF%E8%83%BD%E4%B8%8D%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%B4%BE%E7%94%9Fstate/"/>
    <id>https://feidom-up.github.io/2020/12/28/%E4%BD%A0%E5%8F%AF%E8%83%BD%E4%B8%8D%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%B4%BE%E7%94%9Fstate/</id>
    <published>2020-12-28T09:14:17.000Z</published>
    <updated>2021-05-06T02:46:51.789Z</updated>
    
    <content type="html"><![CDATA[<p><a class="link"   href="https://zh-hans.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html"  target="_blank" rel="noopener">你可能不需要使用派生state<i class="fas fa-external-link-alt"></i></a></p><p>文中列举了两种反模式的使用方式</p><ul><li>直接复制prop到state</li><li>在props变化后修改state</li></ul><p>这两种使用方式除了增加代码的维护成本外，没有任何的好处</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a class=&quot;link&quot;   href=&quot;https://zh-hans.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html&quot;  target=&quot;_blank&quot; rel=&quot;noop
      
    
    </summary>
    
    
      <category term="react" scheme="https://feidom-up.github.io/categories/react/"/>
    
    
      <category term="react" scheme="https://feidom-up.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>webpack优化之代码分割splitChunck</title>
    <link href="https://feidom-up.github.io/2020/12/21/webpack%E4%BC%98%E5%8C%96%E4%B9%8B%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2/"/>
    <id>https://feidom-up.github.io/2020/12/21/webpack%E4%BC%98%E5%8C%96%E4%B9%8B%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2/</id>
    <published>2020-12-21T06:06:00.000Z</published>
    <updated>2021-05-06T02:46:51.789Z</updated>
    
    <content type="html"><![CDATA[<h4 id="代码分割"><a href="#代码分割" class="headerlink" title="代码分割"></a>代码分割</h4><ul><li>splitChunck</li><li>动态引用<ul><li>适用场景：抽离相同代码到一个共享块</li><li>脚本懒加载，使得初始下载代码更小</li></ul></li><li>懒加载JS脚本方式<ul><li>CommonJS: require.ensure</li><li>ES6: 动态import（需要babel支持，@babel/plugin-syntax-dynamic-import)</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置.babelrc</span></span><br><span class="line"><span class="string">"plugins"</span>: [</span><br><span class="line">    [<span class="string">"@babel/plugin-syntax-dynamic-import"</span>],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>dist代码通过window[‘webpackJsonp’]来获取对应脚本</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;代码分割&quot;&gt;&lt;a href=&quot;#代码分割&quot; class=&quot;headerlink&quot; title=&quot;代码分割&quot;&gt;&lt;/a&gt;代码分割&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;splitChunck&lt;/li&gt;
&lt;li&gt;动态引用&lt;ul&gt;
&lt;li&gt;适用场景：抽离相同代码到一个共享块&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="webpack" scheme="https://feidom-up.github.io/categories/webpack/"/>
    
    
      <category term="前端工程化" scheme="https://feidom-up.github.io/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
      <category term="webpack" scheme="https://feidom-up.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack优化之Scope Hoisting</title>
    <link href="https://feidom-up.github.io/2020/12/21/webpack%E4%BC%98%E5%8C%96%E4%B9%8BScopeHoisting/"/>
    <id>https://feidom-up.github.io/2020/12/21/webpack%E4%BC%98%E5%8C%96%E4%B9%8BScopeHoisting/</id>
    <published>2020-12-21T05:58:20.000Z</published>
    <updated>2021-05-06T02:46:51.789Z</updated>
    
    <content type="html"><![CDATA[<h4 id="webpack打包现象"><a href="#webpack打包现象" class="headerlink" title="webpack打包现象"></a>webpack打包现象</h4><p>webpack构建后的代码存在大量的闭包代码</p><ul><li>大量函数闭包包裹代码，导致体积增大(模块越多越明显)</li><li>运行代码时创建的函数作用域变多，内存开销变大</li><li>被webpack转换后的模块会带上一层包裹，import会被转换成<strong>webpack_require</strong></li></ul><h4 id="Scope-Hoisting原理"><a href="#Scope-Hoisting原理" class="headerlink" title="Scope Hoisting原理"></a>Scope Hoisting原理</h4><ul><li>将所有模块的代码按照引用顺序放在一个函数作用域中，然后适当的重命名一些变量以防止变量名冲突</li><li>对比，通过scope hoisting 可以减少函数声明代码和内存开销</li></ul><h4 id="开启scope-hoisting"><a href="#开启scope-hoisting" class="headerlink" title="开启scope hoisting"></a>开启scope hoisting</h4><ul><li>webpack4 mode 为 production默认开启，必须是ES6语法，commonJS不支持</li><li>webpack3 增加插件 new webpack.optimize.ModuleConcatenationPlugin()</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;webpack打包现象&quot;&gt;&lt;a href=&quot;#webpack打包现象&quot; class=&quot;headerlink&quot; title=&quot;webpack打包现象&quot;&gt;&lt;/a&gt;webpack打包现象&lt;/h4&gt;&lt;p&gt;webpack构建后的代码存在大量的闭包代码&lt;/p&gt;
&lt;ul&gt;
&lt;l
      
    
    </summary>
    
    
      <category term="webpack" scheme="https://feidom-up.github.io/categories/webpack/"/>
    
    
      <category term="前端工程化" scheme="https://feidom-up.github.io/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
      <category term="webpack" scheme="https://feidom-up.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack优化之tree-shaking</title>
    <link href="https://feidom-up.github.io/2020/12/21/webpack%E4%BC%98%E5%8C%96%E4%B9%8BTreeShaking/"/>
    <id>https://feidom-up.github.io/2020/12/21/webpack%E4%BC%98%E5%8C%96%E4%B9%8BTreeShaking/</id>
    <published>2020-12-21T05:57:47.000Z</published>
    <updated>2021-05-06T02:46:51.789Z</updated>
    
    <content type="html"><![CDATA[<h4 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree-shaking"></a>tree-shaking</h4><ul><li>静态分析，不是动态分析</li><li>代码不会被执行到，就不会打包到bound.js</li><li>必须使用ES6的语法(import、export)才支持tree-shaking，commonjs方式不支持</li><li>webpck默认支持，在.babelrc里面设置 modules: false即可，同时mode=production默认开启</li></ul><h4 id="tree-shaking原理"><a href="#tree-shaking原理" class="headerlink" title="tree-shaking原理"></a>tree-shaking原理</h4><ul><li>只能作为模块顶层的语句出现</li><li>import的模块只能是字符串常量   export function() {}</li><li>import binding 是 immutable 的</li></ul><p>代码擦除: uglify阶段删除无用代码</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;tree-shaking&quot;&gt;&lt;a href=&quot;#tree-shaking&quot; class=&quot;headerlink&quot; title=&quot;tree-shaking&quot;&gt;&lt;/a&gt;tree-shaking&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;静态分析，不是动态分析&lt;/li&gt;
&lt;li&gt;代码不
      
    
    </summary>
    
    
      <category term="webpack" scheme="https://feidom-up.github.io/categories/webpack/"/>
    
    
      <category term="前端工程化" scheme="https://feidom-up.github.io/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
      <category term="webpack" scheme="https://feidom-up.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack4&amp;&amp;ESlint</title>
    <link href="https://feidom-up.github.io/2020/12/15/webpack4&amp;&amp;ESlint/"/>
    <id>https://feidom-up.github.io/2020/12/15/webpack4&amp;&amp;ESlint/</id>
    <published>2020-12-15T08:23:27.000Z</published>
    <updated>2021-05-06T02:46:51.788Z</updated>
    
    <content type="html"><![CDATA[<h4 id="ESlint"><a href="#ESlint" class="headerlink" title="ESlint"></a>ESlint</h4><p>ESLint是一个用来识别ECMAScript 并且按照规则给出报告的代码检测工具，使用它可以避免低级错误和统一代码的风格。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.eslint.js</span></span><br><span class="line"><span class="comment">// 区分生产环境、开发环境</span></span><br><span class="line"><span class="keyword">const</span> _mode = process.env.NODE_ENV || <span class="string">'production'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="string">"env"</span>: &#123;</span><br><span class="line">        <span class="string">"browser"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"es6"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"node"</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"globals"</span>: &#123;</span><br><span class="line">        <span class="string">"$"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"process"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"dirname"</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"parser"</span>: <span class="string">"babel-eslint"</span>,</span><br><span class="line">    <span class="string">"extends"</span>: <span class="string">"eslint:recommended"</span>,</span><br><span class="line">    <span class="string">"parserOptions"</span>: &#123;</span><br><span class="line">        <span class="string">"ecmaFeatures"</span>: &#123;</span><br><span class="line">            <span class="string">"jsx"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">"legacyDecorators"</span>: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"ecmaVersion"</span>: <span class="number">2018</span>,</span><br><span class="line">        <span class="string">"sourceType"</span>: <span class="string">"module"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"plugins"</span>: [</span><br><span class="line">        <span class="string">"react"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"rules"</span>: &#123;</span><br><span class="line">        <span class="string">"no-console"</span>: <span class="string">"off"</span>,</span><br><span class="line">        <span class="string">"no-debugger"</span>: _mode===<span class="string">'development'</span> ? <span class="number">0</span> : <span class="number">2</span>,</span><br><span class="line">        <span class="string">"no-alert"</span>: _mode===<span class="string">'development'</span> ? <span class="number">0</span> : <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// "no-multi-spaces": "error",</span></span><br><span class="line">        <span class="string">"no-unused-vars"</span>: <span class="string">"off"</span>, <span class="comment">// react中不适用</span></span><br><span class="line">        <span class="string">"no-constant-condition"</span>: <span class="string">"off"</span>,</span><br><span class="line">        <span class="string">"no-fallthrough"</span>: <span class="string">"off"</span>,</span><br><span class="line">        <span class="comment">// "keyword-spacing": ["error", &#123; "before": true&#125; ], // 不生效，先注释</span></span><br><span class="line">        <span class="comment">// "indent": [</span></span><br><span class="line">        <span class="comment">//  "error",</span></span><br><span class="line">        <span class="comment">//  2</span></span><br><span class="line">        <span class="comment">// ],</span></span><br><span class="line">        <span class="string">"linebreak-style"</span>: [</span><br><span class="line">        <span class="string">"error"</span>,</span><br><span class="line">        <span class="string">"unix"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="comment">// "quotes": [</span></span><br><span class="line">        <span class="comment">//  "error",</span></span><br><span class="line">        <span class="comment">//  "single"</span></span><br><span class="line">        <span class="comment">// ],</span></span><br><span class="line">        <span class="string">"semi"</span>: [<span class="number">0</span>],</span><br><span class="line">        <span class="string">"no-unexpected-multiline"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">"no-class-assign"</span>: <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="检查eslint"><a href="#检查eslint" class="headerlink" title="检查eslint"></a>检查eslint</h4><ul><li>方式一: 安装husky，增加npm script，适合老项目</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="comment">//"precommit": "eslint --ext .js --ext .jsx src/",</span></span><br><span class="line">    <span class="string">"precommit"</span>: <span class="string">"eslint lint-staged"</span>, <span class="comment">// 增量检查修改的文件  </span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"lint-staged"</span>: &#123;</span><br><span class="line">    <span class="comment">//"src/**/*.js": [</span></span><br><span class="line">    <span class="comment">//  "eslint --ext .js --ext .jsx",</span></span><br><span class="line">    <span class="comment">//  "git add"</span></span><br><span class="line">    <span class="comment">//]</span></span><br><span class="line">    <span class="string">"linters"</span>: &#123;</span><br><span class="line">        <span class="string">"*.[js,scss]"</span>: [<span class="string">"eslint --fix"</span>, <span class="string">"git add"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方式二：webpack与eslint结合，新项目</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">    &#123;</span><br><span class="line">        test: <span class="regexp">/\.jsx?$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        use: [<span class="string">'babel-loader'</span>, <span class="string">'eslint-loader'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>其实新项目中，可以将两种方式同时使用</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;ESlint&quot;&gt;&lt;a href=&quot;#ESlint&quot; class=&quot;headerlink&quot; title=&quot;ESlint&quot;&gt;&lt;/a&gt;ESlint&lt;/h4&gt;&lt;p&gt;ESLint是一个用来识别ECMAScript 并且按照规则给出报告的代码检测工具，使用它可以避免低级错误和
      
    
    </summary>
    
    
      <category term="webpack" scheme="https://feidom-up.github.io/categories/webpack/"/>
    
    
      <category term="前端工程化" scheme="https://feidom-up.github.io/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
      <category term="webpack" scheme="https://feidom-up.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack4定位源代码source-map</title>
    <link href="https://feidom-up.github.io/2020/12/15/webpack4%E5%AE%9A%E4%BD%8D%E6%BA%90%E4%BB%A3%E7%A0%81source-map/"/>
    <id>https://feidom-up.github.io/2020/12/15/webpack4%E5%AE%9A%E4%BD%8D%E6%BA%90%E4%BB%A3%E7%A0%81source-map/</id>
    <published>2020-12-15T08:22:25.000Z</published>
    <updated>2021-05-06T02:46:51.788Z</updated>
    
    <content type="html"><![CDATA[<h4 id="定位源代码"><a href="#定位源代码" class="headerlink" title="定位源代码"></a>定位源代码</h4><ul><li><p>通过 source-map 定位到源代码</p></li><li><p>开发环境：建议使用</p><ul><li>首先在源代码的列信息是没有意义的，只要有行信息就能完整的建立打包前后代码之间的依赖关系。因此不管是开发环境还是生产环境，我们都会选择增加cheap基本类型来忽略模块打包前后的列信息关联。</li><li>其次，不管在生产环境还是开发环境，我们都需要定位debug到最最原始的资源，比如定位错误到jsx，coffeeScript的原始代码处，而不是编译成js的代码处，因此，不能忽略module属性</li><li>再次我们希望通过生成.map文件的形式，因此要增加source-map属性</li></ul></li><li><p>线上环境关闭</p></li><li><p>eval：使用<code>eval</code>包裹模块代码</p></li><li><p>cheap：不包含列信息</p></li><li><p>inline：将.map作为DataURI嵌入，不单独生成.map文件</p></li><li><p>module：包含loader的source</p></li><li><p>source-map 类型</p></li></ul><table><thead><tr><th align="left">devtool</th><th align="left">首次构建</th><th align="left">二次构建</th><th align="left">是否适合生产环境</th><th align="left">可以定位的代码</th></tr></thead><tbody><tr><td align="left">(none)</td><td align="left">+++</td><td align="left">+++</td><td align="left">yes</td><td align="left">最终输出的代码</td></tr><tr><td align="left">eval</td><td align="left">+++</td><td align="left">+++</td><td align="left">no</td><td align="left">webpack生成的代码块（一个个的模块）</td></tr><tr><td align="left">cheap-eval-source-map</td><td align="left">+</td><td align="left">++</td><td align="left">no</td><td align="left">经过loader转换后的代码（只能看到行）</td></tr><tr><td align="left">cheap-module-eval-source-map</td><td align="left">o</td><td align="left">++</td><td align="left">no</td><td align="left">源代码（只能看到行）</td></tr><tr><td align="left">eval-source-map</td><td align="left">–</td><td align="left">+</td><td align="left">no</td><td align="left">源代码</td></tr><tr><td align="left">cheap-source-map</td><td align="left">+</td><td align="left">o</td><td align="left">yes</td><td align="left">经过loader转换后的代码（只能看到行）</td></tr><tr><td align="left">cheap-module-source-map</td><td align="left">o</td><td align="left">-</td><td align="left">yes</td><td align="left">源代码（只能看到行）</td></tr><tr><td align="left">inline-cheap-source-map</td><td align="left">+</td><td align="left">o</td><td align="left">no</td><td align="left">经过loader转换后的代码（只能看到行）</td></tr><tr><td align="left">inline-cheap-module-source-map</td><td align="left">o</td><td align="left">-</td><td align="left">no</td><td align="left">源代码（只能看到行）</td></tr><tr><td align="left">source-map</td><td align="left">–</td><td align="left">–</td><td align="left">yes</td><td align="left">源代码</td></tr><tr><td align="left">inline-source-map</td><td align="left">–</td><td align="left">–</td><td align="left">no</td><td align="left">源代码</td></tr><tr><td align="left">hidden-source-map</td><td align="left">–</td><td align="left">–</td><td align="left">yes</td><td align="left">源代码</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.expors = &#123;</span><br><span class="line">  <span class="comment">// 开发,因为eval的rebuild速度快，因此我们可以在本地环境中增加eval属性</span></span><br><span class="line">  devtool: <span class="string">'cheap-module-eval-source-map'</span></span><br><span class="line">  <span class="comment">// 生产</span></span><br><span class="line">  devtool: <span class="string">'cheap-module-source-map'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>本博客笔记内容主要来自<strong>京城一灯</strong>公众号 前端先锋 </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;定位源代码&quot;&gt;&lt;a href=&quot;#定位源代码&quot; class=&quot;headerlink&quot; title=&quot;定位源代码&quot;&gt;&lt;/a&gt;定位源代码&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;通过 source-map 定位到源代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;开发环境：建议使用&lt;/
      
    
    </summary>
    
    
      <category term="webpack" scheme="https://feidom-up.github.io/categories/webpack/"/>
    
    
      <category term="前端工程化" scheme="https://feidom-up.github.io/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
      <category term="webpack" scheme="https://feidom-up.github.io/tags/webpack/"/>
    
  </entry>
  
</feed>
